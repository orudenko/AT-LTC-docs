## Типы и структуры данных

Как мы уже говорили где-то на предыдущих лекциях, все данные в памяти компьютера представлены последовательностями байтов. В принципе, и в таком виде с ними можно работать, и иногда приходится. Но в большинстве языков программирования информация собирается из типов данных (*value types*), организованных в структуры данных (*data structures*) — а уже потом, на этапе компиляции или интерпретации, они отображаются в последовательности байтов в памяти (к которым часто даже нет прямого доступа).

### Примитивы

Элементарные типы данных называются *"примитивы"*. В разных языках программирования есть разные представления о том, что считать примитивом. Например, в C их очень много (и каждый может нести несколько названий, что запутывает), но вообще примитивные типы C - это либо разного рода числа, либо указатели. Примитивного типа "строка" в C нет, строка, как мы помним, это последовательность ASCII (или Unicode)-кодов, заканчивающаяся байтом `00`. Нет и логических типов. Только числа (целые и дробные, точнее, с плавающей точкой), и адреса в памяти. Благодаря такому минимализму, компиляторы C существуют для чего угодно, хоть для часов и холодильников.

Про числа вы знаете (более подробно мы о них поговорим позднее), а указатель — это «адрес в памяти», ссылка на какое-то другое значение (сопровождаемая в коде — но не в памяти — информацией о том, что это такое может быть).

В Javascript типизация слабая — одно и то же значение вроде `"1.2"` в разных контекстах может быть интерпретировано и как строка, и как число (что создаёт немало проблем). Но всё-таки примитивные типы есть и там, хотя они и не подразделяются на бесчисленные подкатегории как в C (где одних числовых типов больше десятка). Зато в Javascript — не одни числа, а вот что:

* Логический тип (Boolean) — содержит только два значения, true и false. Операции сравнения, например, выдают результатом именно его;

* Неопределённый тип (Undefined) — если переменную просто определить, но не задать сразу её значение, оно будет именно таковым. Существует ровно одно значение типа Undefined — это undefined. :) Его любой программист на джаваскрипте видит часто;

* Числовой тип (Number). В отличие от C, числа в Javascript это "просто числа", а именно все числа — это 64-битные дробные числа с плавающей точкой. Про то, как устроено представление таких чисел, мы расскажем позднее, а пока упомянем, что это числа в двоичном представлении, вычисления с которыми создают небольшие погрешности в десятичном представлении. Поэтому нужно быть очень осторожными, сравнивая их.

Например, запустите REPL node.js и проверьте там результат выражения:

    (0.2 * 0.2) == 0.04

ну и просто

    0.2 * 0.2

Такие дела;

* Строковый тип  (String). «Просто строки», последовательности «текстовых символов» неопределённой длины. Худо-бедно в джаваскрипте поддерживается юникод, с разной степенью смеха. Можно, например, попробовать операции смены регистра `string.toUpperCase` / `string.toLowerCase` для строки с вашими любимыми эмодзи.

Ещё в джаваскрипте есть примитивные типы *Null* («определённо пустое значение», в отличие от неопределённого undefined) и *Symbol* (уникальная строка) — последний новый и применяется редко. Больше примитивных типов в этом языке нет, все остальные типы — составные.

**– почему ((0.2 * 0.2) == 0.04) считает как false?**

**– потому что компьютер считает дробные числа двоичной, а не десятичной арифметикой. В ней хорошо представляются двоичные дроби со знаменателем, кратным степени двойки (например, 1/4 или 1/512); привычные нам десятичные дроби можно представить лишь приближённо.

Это очень плохо; хотя сейчас можно было бы уже исправить ситуацию и сделать нормальные десятичные дроби примитивом, всем лень. Поэтому пока нужно запомнить, что сравнивать нецелые числа напрямую (кроме редких исключений, когда вы точно знаете что делаете — а пока вы не знаете) — нельзя. :((**

Функции в джаваскрипте — тоже тип данных, который можно считать примитивным. Функции можно не только вызывать, но и присваивать переменным и передавать аргументами (а также функция может возвращать другую функцию), что бывает очень полезно. 

Сейчас дам ссылку на интересную статью Спольски про это:

[Can Your Programming Language Do This?](https://www.joelonsoftware.com/2006/08/01/can-your-programming-language-do-this/)

(рекомендую почитать — как часть лекционного материала)

В C есть тип «указатель на функцию», предназначенный для того же самого.

**– а он по сути тоже "адрес в памяти", начиная с которого идет какой-то код, или это абстракция?**

**– да, по большому счёту так.**

Тут нужно сделать интерлюдию — сказать, что языки программирования разделяются по уровню типизации.

### Уровни типизации

Типизация бывает слабая или сильная, а также статическая или динамическая.

Например, у C статическая и слабая типизация, а у Javascript — динамическая и слабая.

Сильная типизация означает, что значение одного типа не может быть проинтерпретировано как значение другого типа без явных преобразований — а слабая, соответственно, что может.

Как в C, так и в Javascript, такая операция возможна без особых ухищрений. Если же результат такой операции не очень имеет смысл, программа выдаст ошибку в процессе выполнения (а компилятор вам про неё не сообщит, поэтому искать такие ошибки бывает очень увлекательно).

Например, попробуйте умножить в Javascript строку на какое-нибудь число. Эта операция возможна, и компилятор не пожалуется! Результатом будет NaN (not a number — специальное псевдо-число, зарезервированное за результатами некоторых арифметических операций, вроде квадратного корня из минус единицы за неимением комплексных чисел). В общем, бардак.

В языках с сильной типизацией такие вещи невозможны, поэтому многие ошибки удаётся отловить раньше. Насколько раньше — это решается в дилемме "статическая/динамическая".

В C типизация статическая, то есть при объявлении переменных, декларировании аргументов функции и того, что она возвращает, нужно обязательно сразу указывать их тип (вроде `int i = 42` или `char* s = "Hello!"`).

Это помогает: после этого переменной типа int уже нельзя присвоить строку, и наоборот (а в Javascript пожалуйста).

В Javascript с динамической типизацией тип переменных нигде в коде не указывается, и любой переменной может быть присвоено любое значение, и любая функция тоже может возвращать всё что угодно. Допустить ошибки в таком языке проще, а отлаживать код соответственно сложнее.

Наиболее известный язык с сильной и статической типизацией — Java. Он многословный, но зато позволяет избежать целого класса ошибок, распространённых в языках без статической/сильной типизации. Но Java это такой "необходимый минимум", есть сильно и статически типизированные языки с гораздо более широкими возможностями (например, Rust, Scala и Haskell). Про них ходит шутка "если программа скомпилировалась, она работает" — и часто это действительно так, хотя добиться этой компиляции бывает непросто.

Языки с сильной, но динамической типизацией редки, но существуют (например, Smalltalk).

### Структуры данных 

Одними примитивными типами программировать неудобно, поэтому существуют составные типы, они же структуры данных (последний термин более низкоуровневый, обычно подразумевает их внутреннее устройство).

Почти во всех языках программирования существуют типы-*последовательности* (отличающиеся внутренним устройством: это могут быть связанные списки, массивы и более экзотические конструкции, например множества) и типы-*словари* (деревья, хэш-таблицы, и другие). Ещё бывают *tuples*, или *структуры* — жёстко заданные совокупности примитивных типов (в отличие от словарей, в которых содержимое можно задавать динамически в процессе выполнения программы).

Например, `int[]` — это тип-последовательность "массив целых чисел" в C. Поскольку память в C выделяется вручную, нужно сразу указывать его размер при инициализации, что тоже приводит к множеству забавных ошибок. В Javascript есть встроенный тип "массив чего угодно", например, `[]` это пустой массив, а `[1,2,3,4,5]` это массив с числами.

С последовательностями, массивами в том числе, возможны какие-то стандартные операции. Можно узнать его длину (в C и это нетривиально, но несложно). Существует индексирование, то есть выбор элемента по его порядковому номеру (начиная с нуля). Бывает возможным разбить последовательность на несколько по какому-то критерию, или скопировать одну в другую.

Массив отличается от связанного списка тем, что в массиве значения всегда находятся друг рядом с другом в памяти, а в связанном списке — не обязательно, там просто каждый элемент указывает на следующий (бывает двусвязный список, там и на предыдущий). Это влияет на скорость операций: например, в большой массив сложно вставить элемент в середину, а в большой связанный список это сделать тривиально. Зато в массивах можно очень быстро получить элемент по его индексу, а в связанном списке для этого придётся проходить элементы один за другим, пока не достигнешь нужного.

(В стандартной библиотеке как Javascript, так и C связанных списков нет, только массивы. При этом в C они ещё и не динамические, то есть добавлять/удалять элементы нельзя — можно только создать массив побольше-поменьше и скопировать туда элементы из предыдущего. Но всё это и многое другое есть в сторонних библиотеках).

Я тут решил попробовать давать меньше материала, но каждый день, так что про словари (и объекты в JS) будет уже завтра. А на сегодня небольшое задание:

### Задание. Игры с типами

Посмотрите и попробуйте, как в C и Javascript (начните с Javascript) можно:

* создать массив чисел;
* создать массив строк;
* узнать длину массива;
* получить элемент по индексу;
* получить последний элемент;

и только в javascript:

* добавить элемент в начало;
* добавить элемент в конец;
* удалить элемент по индексу;
* объединить два массива в один;
* применить функцию ко всем элементам массива и получить новый той же длины.

### Ссылка на примитивы языка C

Да, про примитивные типы в C я забыл рассказать, так как там очень много числовых типов разных размеров, но их можно посмотреть например тут: https://en.wikipedia.org/wiki/C_data_types
