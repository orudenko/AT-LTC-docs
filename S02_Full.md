## S02E01. Интерлюдия: форматы данных

Сегодня мы поговорим о способах представления информации компьютерами. Как мы все знаем, компьютеры внутри себя способны работать только с нулями и единицами; тем не менее, на экранах мы видим буковки, цифирки и картинки с котиками. Логичный вывод — компьютеры представляют котиков и тексты про них в качестве двоичных чисел, а как это происходит — мы сейчас разберём.

На заре теплоты и ламповости инженеры установили, что будет удобнее всего группировать нолики и единицы (биты) в группы по восемь штук (байты). Соответственно, когда компьютеры читают и записывают числа в память, они это делают с минимальной группой по 8 бит: от 00000000 до 11111111, или в десятичном представлении от 0 до 255. 

“Немало" — подумали инженеры (а компьютеры тогда придумывались в основном в США и возможно немножко в европейских странах с латинским алфавитом, ну может ещё иногда в СССР, где букв тоже немного), и решили поставить некоторые числа в соответствии с некоторыми буквами и символами. Букв в английском алфавите 26, берём большие и маленькие — значит, 52, да ещё 10 цифр, да знаки препинания, да управляющие команды — ура, точно влезает! Влезло даже в 7 бит (127 возможных значений), а восьмой оставили на будущее, и для поддержки других кодировок (в другие 127, например, можно засунуть русский алфавит). 

Эта таблица соответствий для первых 127 символов (их было несколько, но победила только одна) стала называться кодом ASCII: https://ru.wikipedia.org/wiki/ASCII.

Соответственно, все компьютеры, операционные системы и программы, понимающие что такое ASCII (а сейчас это почти все и везде) знают, что если речь идёт о тексте, то байт с числом 32 это пробел, а 107 — буква k, и т.д. Байты обычно записываются в шестнадцатеричной системе счисления, потому что так они удобно вмещаются в два символа, от 00 до FF, вместо десятичных от 0 до 255 (и арифметика больше похожа на двоичную). Поэтому обычно записывают байт, соответствующий пробелу, как 20, а букве k — 6B. Чтобы не путать системы счисления, шестнадцатеричные числа записывают как 0x6B, или 6Bh. Откуда взялся префикс 0x, это отдельная грустная история, которая доказывает что у программистов нет ни ума, ни фантазии (но все привыкли). 

Соответственно, строка `Hello, world!` видится компьютерам (и языкам программирования) как последовательность байт: 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21.

Всё бы ничего, но как же понять, где эта строка заканчивается? После неё в памяти могут идти и другие байты. Можно предложить несколько решений, и по ряду причин победило не лучшее из них.

Первое, очевидное решение: указать два адреса (места расположения) в памяти, где хранятся начало и конец строки. Программисты взбунтовались, как же так, это сколько лишней памяти тратится? Для 64-битного компьютера (который поэтому и называется 64-битным) адрес (это тоже число) занимает 64 бита, то есть 8 байт. И если содержимое строки "fuck" само по себе занимает 4 байта, то её начало и конец добавят ещё по 8, и так для каждой строки. 4 и 20 — есть разница? Память-то не резиновая, что бы ни думал Chrome по этому поводу. Поэтому такой метод распространения не получил.

Следующий вариант — указывать в начале каждой строки её длину. Например, `Hello, world! занимает 13 байтов, добавим число 13 (или в шестнадцатиричном представлении 0d) в начале:  0d, 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21, и научим программы, что сначала читаем из памяти длину строки, а потом столько байтов, сколько указано в длине. Это хороший метод, который и память экономит, и позволяет не тратить время на подсчёт длины и множество других операций, но так можно закодировать только строки длиной до 255 символов, по очевидным причинам. Для твиттера пойдёт (и то там уже 280), но для ЖЖ уже не очень. Два байта дают возможность кодировать строки до (256*256)-1=65535 символов в длину, но и этого может быть недостаточно, и кроме того, как договориться, в каких строках хватит одного байта для длины, а в каких нужно два? (Программисты, как известно, никогда не могут ни о чём договориться друг с другом). Поэтому и этот способ распространения не получил, хотя некоторые программы его используют.

Наконец, кто-то решил, что давайте поступим максимально тупо — просто конец каждой строки будем обозначать байтом 00, чтобы никто не догадался. Как программа видит 00 — так и считаем, что строка закончилась. На том и порешили, так теперь в большинстве языков, программ и операционных систем всё и происходит. Это создаёт множество проблем (стоит убрать нулевой байт откуда-нибудь, и программа спокойненько читает дальше память, которая ей не предназначена, а если вставить в строку нулевой байт специально, то тоже ничего хорошего не получится). Но такова селяви, живём теперь с этим.

Теперь вы знаете, что Hello, world! компьютер обычно видит как 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21, 00. Ну или если переходить прямо к ноликам и единицам, то 01001000, 01100101, 01101100, 01101100, 01101111, 00101100, 00100000, 01110111, 01101111, 01110010, 01101100, 01100100, 00100001, 00000000

Для английского языка всё так и осталось; символы других языков представляются несколько сложнее. После дикого периода, когда одновременно существовало множество разных национальных кодировок (деды пугали, что на каждом сайте приходилось выбирать KOI-8, CP-1251 и какие-то другие ужасы), программисты придумали наконец универсальное решение: Unicode

У Unicode есть два слоя: абстрактное представление, и непосредственно способ кодирования. Абстрактное представление — это просто (сколь угодно большое) число, которому поставлен в соответствие почти каждый символ, который успело придумать человечество в разных естественных языках, а заодно псевдографику, математические символы, и даже эмодзи с какашкой: 💩. Он, кстати, находится в списке Unicode под номером 55357, или в шестнадцатеричном представлении — 1f4a9.

Это не означает, что мы можем просто так взять и записать число 1f4a9 где-нибудь (это займёт три байта — 01, f4, a9 — иногда в обратном порядке, потому что программисты не могут договориться даже об этом), и программа сразу поймёт, что имеется в виду именно этот эмодзи. Потому что как можно отличить его, допустим, от трёх разных символов, обозначаемых байтами 01, f4 и a9 по-отдельности?

В общем, после многочисленных бурных дискуссий, в результате которых родилось и погибло (но не до конца) множество промежуточных представлений Unicode, программисты родили более или менее универсальную кодировку UTF-8, которая теперь применяется почти везде (за некоторыми смешными исключениями, о которых я потом расскажу по просьбам комментирующих в личку). Устроена она так.

Все символы ASCII (латинский алфавит, цифры, управляющие последовательности, знаки препинания и немного псевдографики), как и раньше, кодируются одним байтом от 0 до 127, то есть от 00 до 7F.

Все символы, в списке Unicode обозначаемые номерами больше 7F, но меньше 7FF (с 80 по 2047), кодируются двумя байтами, по хитрому двоичному шаблону: 110xxxxx 10xxxxxx (вместо иксов вставляем биты двоичного представления номера символа). То есть когда компьютер видит байт, начинающийся в двоичном виде с 1, он знает, что речь точно идёт не о ASCII, а если он ещё и начинается со 110, то это первый байт из двух нужных для прочтения представления символа до 7FF. Русские буквы входят в эту область.

Соответственно, символы далее по списку кодируются двоичным шаблоном 1110xxxx 10xxxxxx 10xxxxxx (три байта; туда входят иероглифы и эмодзи), а ещё дальше -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (четыре байта, там уж совсем экзотика). Больше четырёх байтов в UTF-8 сейчас не бывает, и последний символ, который можно так закодировать, имеет номер 10ffff (или в десятичном представлении - 1 114 111). Should be enough for everyone!

Разумеется, количество драмы после введения Unicode/UTF-8 ничуть не уменьшилось. Например, русская А и латинская A это один и тот же символ, или разные? Решили, что разные. А вот к примеру, 人 в японском языке и 人 в китайском? Решили, что один и тот же, потому что если каждый иероглиф в каждом языке обозначать разными способами, то вообще никакой памяти не хватит. Японцы страшно обиделись, разумеется.

Есть и другие проблемы: арабы с евреями пишут справа налево, но в строке могут встречаться цифры и латинские слова, которые слева направо. Для этого в Unicode есть управляющие последовательности смены направления чтения, которые отлично конфликтуют друг с другом и всем остальным и часто плохо работают

*—Если первый байт показывает значимое количество байтов в слове, зачем первые два бита 10 во втором и последующих байтах слова?*
*—Потому что если строка разобьётся на несколько частей в произвольном месте по байтам, так можно понять, с этого байта начинается символ или это продолжение какого-то.*

Также теперь размеры строк в памяти не соответствуют количеству символов, и тривиального способа определить размер utf8-строки самостоятельно не существует (помимо того что один символ занимает произвольное количество байт от 1 до 4, ещё есть диакритики, нормализация и чёрт знает что.) К счастью, авторы стандартных библиотек для распространённых языков программирования уже съели свою норму 💩, и теперь можно пользоваться библиотечными операциями для работы с Unicode почти везде.

Помимо строк, программисты придумали как кодировать что угодно. Картинки? Например, 4 байта на каждый пиксель, для уровней красного, синего, зелёного, и прозрачности (так это занимает очень много места, поэтому потом картинки сжимаются в джипеги или гифки хитромудрыми алгоритмами).

Звук? По два байта (то есть число от 0 до 65535) для значения амплитуды звуковой волны в каждый текущий момент времени, и так 48 тысяч раз в секунду (тоже немало места, и тоже очень сложные алгоритмы сжатия с потерями делают из этого mp3 — но сначала звук представляется именно в таком формате).

Команды машинного кода, которые понимает процессор — тоже записываются каким-то количеством байт (и тоже разным, чтобы программисты не скучали). Для процессоров Intel команда add, складывающая два числа, обозначается (в разных вариантах) байтами 00 или 01 или 02 или 03 или 05, а также иногда (не спрашивайте) 80 или 81.

К счастью, работать непосредственно с представлением в байтах нужно только на уровне системного программирования, а на высоком уровне можно вставлять эмодзи прямо в текст программы, или говорить библиотеке «а сделай этот звуковой файл чуть погромче». Но знать, с чем имеешь дело, всё равно нужно.

## S02E02. Git и Github. Системы контроля версий — от создателей Новая Папка(13)!

### Git: введение

(Предупреждение: моих скромных педагогических способностей может не хватить на то, чтобы адекватно научить всех пользоваться гитом. Рэндалл Монро, как всегда, рассказал о проблеме лучше меня: https://xkcd.com/1597/. Знание о том, что гит представляет ревизии в виде графа с указателями, никак не помогает лично мне научиться им хорошо пользоваться. Интерфейс командной строки гита ужасен и неинтуитивен, документация написана боевыми аутистами, а книги типа Pro Git тоже только запутывают ситуацию.

К сожалению, гиту нет альтернативы — у наиболее известного конкурента, Mercurial, хватает своих проблем, а кроме того у гита есть гитхаб — социальная сеть для программистов, где они вместе пишут код, иногда по работе, а иногда так, как будто других дел нет (альтернативы гитхабу недостойны упоминания). Затягивает. Вы уже все создали аккаунты на гитхабе, да?)

Сначала небольшая техническая заминка. Чтобы пользоваться гитом и гитхабом, нужно создать пару ключей SSH. Объяснение подробностей работы асимметричного шифрования выходит за рамки данного курса; практическая версия говорит, что для авторизации вместо того, чтобы каждый раз вводить пароль, гит использует ключи шифрования, публичный и приватный. Публичный вы можете показывать другим людям и заливать на гитхаб: он удостоверяет, что вы это вы. Приватный вы держите у себя и никому не показываете. Работает примерно как когда в старых шпионских фильмах два агента разрывают купюру, и узнают друг друга по предъявлению второй половины.

### Практика 2.1: создание ключей

Опустим также подробности о преимуществах и недостатках алгоритмов шифрования (RSA/elliptic curves), драму о вездесущих шпионах NSA, которые пытались ослабить то и другое. Мастерским произволом мы создадим пару ключей так:

    ssh-keygen -t ed25519

После выполнения этой команды в скрытой директории `~/.ssh` должно появиться два файла: `id_ed25519` (это ваш приватный ключ, никому его не показывайте и даже на экран выводить не стоит), и `id_ed25519.pub` (это публичный ключ, который нужно добавить на гитхаб, пригодится и в других местах)

Сделайте `cat ~/.ssh/id_ed25519.pub`, скопируйте то что показалось, залогиньтесь в гитхаб (вы же зарегистрировались там?), выберите Settings `— SSH` and `GPG` keys, `new SSH key`, и запастите текст ключа.

Теперь вы готовы быть Контрибьютором в Опенсорс и Автором Проектов! А если ещё не готовы, я сейчас подожду 10 минут.

(Для удовлетворения любопытства: ed25519 это алгоритм цифровой подписи (EdDSA), параметризованный эллиптической кривой Curve25519, которая так называется потому что у неё один из коэффициэнтов равен 2^255 - 19. Ненужные аутистические подробности: https://en.wikipedia.org/wiki/EdDSA#Ed25519). Поскольку у нас курс не "введение в криптографию", разбирать эллиптические кривые мы не будем. А жаль (зачёркнуто)).

### Системы контроля версий

Итак — как подтвердит любой человек, работающий с компьютером — часто бывает необходимо сохранять промежуточные результаты работы и показывать их другим людям (а то и делать так, чтобы они могли сделать свою часть и прислать отредактированную версию для продолжения работы). Все знают, к какому размножению директорий и имён файлов вроде Отчёт_2018_3_на_этот_раз_точно_финальный_версия2_исправлено.docx это приводит.

Программистов эти проблемы касаются ещё больше: им нужно не только коммуницировать с коллегами, но и искать в промежуточных ревизиях баги и точно выяснять, где они появились (для, допустим, дизайнов в фотошопе эти трудности не так выражены). А также над большим проектом могут работать десятки и сотни людей как муравьи, растаскивающие кусок сахара, и делать так чтобы результаты их труда были видны каждому. Для этого они придумали на свою голову системы контроля версий (ревизий), наиболее распространённой из каковых сегодня является Git.

### Практика 2.2: установка git

Собственно, прямо сейчас нужно взять ваши менеджеры зависимостей ОС (вы ведь не забыли как ими пользоваться?) и установить git (нужный пакет так и называется). Жду :)

### Git: основные понятия

Гит сохраняет содержимое рабочего каталога (содержимое файлов в тех директориях, которые на данный момент отслеживаются) на тот момент времени, когда вы его об этом попросите. Такой слепок состояния называется snapshot, а процедура его создания — commit.

*—Закоммитить - это оттуда?*
*—Да. Но это слово несёт много неоднозначностей. :) Программисты его применяют с тех времён другой системы контроля версий, SVN, когда оно значило "выложить последние внесённые изменения на общий сервер, с которого его могут забрать другие". Гит работает иначе, и его "коммиты" локальны и видны только вам. Залить изменения в общий для команды репозиторий (например, на гитхаб) называется push, и говорят "запушить" :)*

Можно создавать несколько ветвей развития кода: допустим, вы осуществили несколько коммитов (то есть отредактировали код, записали состояние с комментарием, отредактировали ещё и добавили пару файлов, опять записали состояние — потом решили попробовать какую-то безумную идею, создали ветку "черновик", сделали изменения в ней, несколько раз опять записали промежуточные состояния, потом всё получилось, вам не понравилось, и вы решили вернуться обратно к "чистовой" ветке — вот так тоже можно делать).

Можно сравнивать снапшоты (состояния директорий и файлов) между разными ветками и сливать их в одну ветку теми или иными способами. Часто это бывает, когда одну ветку пишет один человек, а другой — другой. Например, когда вы реализуете новую функциональность — вы можете скопировать любой публичный репозиторий (то есть дерево изменений исходного кода) к себе на гитхаб-аккаунт и потом в локальный гит-репозиторий, сделать новый код в отдельной ветке, залить результат обратно на гитхаб и создать формальный запрос к владельцу оригинального репозитория, чтобы он рассмотрел ваши гениальные изменения и интегрировал их в основную ветку кода. Эта процедура называется "пулл-реквест" (pull request); обычно сопровождается большой драмой в комментариях и убеждениями, что с этим новым кодом всё замечательно (со стороны автора), или что его писала курица сломанной лапой (со стороны владельца репозитория). Иногда удаётся найти компромисс, и код включается в основную ветку.

Так происходит коллективное программирование почти во всех публичных проектах и многих непубличных на работе.

### Git: первые команды

Теперь запишем те самые волшебные заклинания, о которых говорилось в xkcd (авось хватит на первое время):

`git init` — запускается в директории нового проекта, создаёт в любой директории с кодом локальный git-репозиторий. Пустой. Добавлять туда код, даже существующий, нужно другими командами.

`git add <имя_файла>` — сказать гиту, что теперь этот файл (или директорию со всеми поддиректориями) нужно добавлять в следующий snapshot. Все изменённые файлы надо добавлять таким образом вручную (или указать ключ в другой команде, git commit -a, который тогда вносит изменения автоматически).

`git commit -m "комментарий"` — собственно, создать снэпшот (коммит), сохранив состояние дерева файлов на данный момент. Параметр -m обязателен. Обычно коммит делается, когда закончен какой-то осмысленный кусок работы, который можно откомментировать. Хотя кого мы обманываем, делается он когда попало, а в качестве комментария пишется "работаю, отвалите".

`git push` — залить ваши коммиты во внешний репозиторий (например, на гитхаб). По умолчанию — только в текущей ветке; можно это сделать во всех ветках (`git push --all`). Гит может пожаловаться, что за это время кто-то уже что-то успел натворить с кодом, и push пройти не может, тогда нужно сделать (точнее, лучше бы это было сделать заранее, но что теперь):

`git pull` -- загрузить новые коммиты из другого репозитория (опять же, скорее всего гитхаба) к вам, опять-таки по умолчанию в текущей ветке. Ветка по умолчанию называется `"master"`, а сервер, с которым вы синхронизируетесь, называется `"origin"` — его конкретный адрес устанавливается обычно один раз при начале работы, гитхаб говорит как.

### Git: практика 2.3

Итак, теперь вам нужно:

* создать директорию с новым проектом, `ltc02`
* добавить туда файл `readme.txt`, с текстом, например, `"LearnToCode Project 2"`
* инициализировать там локальный гит-репозиторий
* добавить файл в проект
* сделать первый коммит, сохраняющий состояние проекта
* создать новый репозиторий на гитхабе 
* добавить данные гитхаба (так, как сказал вам гитхаб при создании нового репозитория — "добавить существующий проект")
* сделать `git push`.

Это, конечно, непросто, но делать нечего. Удачи!

## S02E03. Hello world на JS и С

### JavaScript

С языком Javascript мы уже знакомы, потому что писали на нём последнюю практику. В этот раз мы добавим к нему ещё язык C, на котором будем повторять разбираемые конструкции.

Так, давайте попробуем. На этом модуле мы будем учиться собственно программировать — то есть использовать наиболее распространённые конструкции языков программирования. Разных. Заодно будет немного больше упора на низкоуровневое программирование (и мы даже немного попишем на настоящем ассемблере и напишем на нём код, который компьютер сможет выполнить с самого начала, ещё не загрузив никакую операционную систему, прямо вот этим вот процессором). Когда ещё удастся?

### Практика 2.4 (Hello world на JS)

На данный момент, если вы прошли практику, у вас достаточно знаний, чтобы написать Hello, world на Javascript (программу, которая печатает на экран Hello, world — на Javascript это будет одна строчка). Создайте у себя в директории проекта поддиректорию js, там файл hello.js, напишите соответствующий код и запустите его (это тривиальная задача, но необходимая, потому что без хелловорлда никто не начинает программировать, извините. Традиция-с.)

### C

Теперь рассмотрим то же самое на C. В отличие от Javascript, нельзя просто так взять и написать одну строчку на C, которая бы делала что-то подобное. Нельзя потому что:

1) в голом C нет функции, которая выводила бы что-то на экран. Потому что программы на C могут компилироваться для самых разнообразных условий и устройств, в том числе таких, где нет экрана, а есть только допустим светодиод, которым можно помигать. К счастью, функция, которая таки печатает что-то на экран, входит в стандартную библиотеку, модуль stdio, и называется printf.

(Счастливцы, у которых работает man, могут даже почитать к ней олдскульную документацию прямо из терминала: man 3 printf).

2) в C выполнение программы обязательно начинается с функции main. Это для того, чтобы неповадно было заводить глобальные переменные, доступные для изменения кому попало — то есть в принципе тоже можно, но требует некоторых усилий (пожалуйста, не надо). Так или иначе, эту функцию необходимо написать.

Код функции в C выглядит, упрощая, примерно следующим образом:

    тип_возвращаемого_значения название_функции(тип_аргумента аргумент1, тип_аргумента аргумент2, ...) {
        выражение;
        выражение;
        ...
    }

*— Отступы важны?*
*— Отступы теоретически не важны. На практике нужно писать код так, как другие программисты в текущем проекте, иначе вам прилетит и всё равно заставят.*

Функция в C (и в Javascript) может принимать от нуля до много аргументов (в разных версиях много — от 31 до 127), а возвращает максимум одно значение (можно ни одного). Так повелось. Могло быть и по-другому; в некоторых языках программирования функция может и принимать, и возвращать только одно значение (например в Haskell), а бывает, что можно и принимать, и возвращать много (например, в PL/SQL).

Как правило, функция что-то «делает». Делать она может или чистые вычисления, которые возвращаются тому коду, который её использует, в виде результата — такие функции называются «чистыми» (pure). Или же она помимо этого может производить какие-то действия с окружающим миром, например, печатать строчки на экран, посылать пакеты в сеть, бибикать и всё портить. Такие действия называются «эффекты», а функция с эффектами, соответственно — не чистая.  Отделять чистые функции от нечистых не менее увлекательно, чем животных на ковчеге.

### Практика 2.5 (Hello world на C)

Учиться использовать функции мы будем на следующем занятии, а пока ваша задача — написать наконец hello world на C по шаблону, который я вам дал, зная следующее:

* строчка на экран выводится функцией printf (она принимает первым аргументом строчку — "строковый литерал" — в двойных кавычках; другие аргументы вам не нужны);
* таковая находится в модуле стандартной библиотеки stdio;
* чтобы включить модуль библиотеки, нужно в начале файла с исходным кодом написать #include "имя_модуля.h" (.h -- это расширение заголовочных файлов, о которых я тоже расскажу позднее);
* функция main возвращает значение типа int, и если ничего не возвращать явно — вернёт 0 (это значение используется операционной системой, чтобы узнать, удачно ли завершилось выполнение программы);
* в самом простом виде функция main может быть без аргументов;
* выражения, составляющие тело функции (в данном случае одно) заканчиваются точкой с запятой.

Создайте в проекте директорию "c" (без кавычек, само собой), и в ней файл hello.c, в котором напишите вот это всё. 

Скомпилируйте его командой `cc -o hello hello.c`, и запустите получившуюся программу командой `./hello`

Не забудьте добавить `hello.c` и `hello.js` в гит, сделать коммит, и запушить код на гитхаб! 

Скомпилированный файл программы (`./hello`) в гит добавлять не надо.

Постарайтесь сделать всё это (на этот раз) не заглядывая в интернет — сейчас информации в лекциях достаточно.

Но вообще это плохая идея — интернет для того и даден, чтобы в него заглядывать, а программистам особенно. Чёрт с вами, делайте что хотите, но чтобы к завтрему всё лежало на гитхабе. 🙂

NB Проверил (аж целых пять штук!) Всё должно работать, сейчас я только сделаю несколько общих замечаний.

Как вы, должно быть, заметили, у языков программирования помимо обязательного синтаксиса есть необязательная форма записи, которую принято называть **стилем** (**code style**). То есть, например, в C можно не делать отступы, или не ставить пробелы до/после операторов, или ставить лишние.

Но! Лучше этого не делать и всегда записывать код аккуратно. Компилятору всё равно, но другим программистам (а также вам самим через несколько месяцев) гораздо удобнее читать код, который написан в соответствии с каким-то стандартом стиля (их возможно несколько), чем как попало. Любой код (кроме машинного, да и у того есть текстовое представление) мы пишем не для компьютера, а для людей. Поэтому другие программисты всегда очень придираются к оформлению. Я тоже буду, чтобы было как по-настоящему.

Я сейчас порекомендую стили для C и Javascript. Если вам прямо поперёк горла эти рекомендации, то пишите как знаете, но только чтобы всегда все формы записи были одинаковы. :)

## S02E04. Функции

Так, во-первых, я обнаружил, что забыл написать, как записывается функция в Javascript. Несколькими способами, но сейчас нас интересует такой (наиболее часто встречающийся):

    function имя_функции(аргумент1, аргумент2, ...) {
        выражение;
        выражение;
        ...
    }

Давайте посмотрим, чем это отличается от C.

В Javascript функция всегда обозначается словом `function`, а в C достаточно просто имени и типа возвращаемых данных.

Но это не главное отличие — в Javascript мы не видим типов данных! Потому что их "нет", точнее, типизация динамическая — никто не проверяет, возвращаем мы строку, число или что-то ещё. Если мы пытаемся что-то сделать со значением, что оно не поддерживает (например, умножать строки) — программа на Javascript в этом месте завершит работу с ошибкой во время выполнения. Программа на C же даже не скомпилируется, потому что компилятор знает заранее, какого типа у функций и аргументов значение, и выдаст ошибку сразу при попытке компиляции (это называется **"статическая"** типизация).

Функции, которые вы пишете, можно _вызывать_ в других фрагментах кода (возможно, не один раз, меняя только параметры), и получать результат (и/или какое-то действие). 

Таким образом, функции помимо прочего служат для организации кода.

Правило (не всегда соблюдаемое, но лучше его иметь в виду): в одной функции должен быть код для какого-то одного действия (иногда это очень большое действие — но не относящихся друг к другу вещей лучше внутри одной функции не делать, вам же потом сложнее разобраться будет).

Вызывается функция одинаково и в C, и в Javascript:

    имя_функции(аргумент1, аргумент2, ...)

получившийся результат можно записать в переменную, можно вернуть на уровень выше с помощью `return` (тоже одинаково и там и там), а можно просто использовать прямо вызов функции в качестве аргумента другой функции

Например, в Javascript это так:

    let переменная = имя_функции(аргументы...) 

(вместо `let` может быть `var` или `const`, `var` сейчас лучше не использовать — он засоряет глобальное пространство видимости, а `const` удобен, если вы не собираетесь больше менять значение этой "переменной", то есть это уже не переменная, а константа)

а в C так:

    тип_переменной переменная = имя_функции(аргументы...);

при этом тип переменной должен совпадать с типом возвращаемого значения функции, иначе компилятор вас отругает!

*— Если речь идет не о выборе имен и внутренней структуре, порядке, ... — а только о пробелах и отступах — то почему это не забота редактора?*
*— Если в вашем редакторе есть функция автоматического форматирования кода — конечно, можно использовать её. Лишь бы на гитхабе всё было чётко. :)*

### Практика 2.6 (Функция, печатающая сумму аргументов)

Полученных знаний должно вам хватить, чтобы написать (на C и Javascript) функцию, которая принимает два аргумента (целочисленных на C — напомним, что это тип `int`), и возвращает их сумму. Эту функцию нужно вызвать, сохранить результат в переменную и напечатать получившееся.

В C ещё есть нюанс — функция `printf` принимает только аргументы строкового типа (`char*`), а всё остальное не принимает. Но она умеет работать с шаблонами форматирования (о которых будет отдельная лекция), а пока вот:

`printf("some_variable is %d", some_variable)` подставит значение переменной типа `int` на место `%d`, и выведет получившееся. Можно просто написать `printf("%d", some_variable)`.

Создайте в `js` и `c` файлы `sum.js` и `sum.c`, напишите код с такой функцией, сделайте коммит и пуш на гитхаб.

## S02E05. Функции. Продолжение: условные и логические операции 

Как я говорил в самой первой лекции, программы описывают исполнение команд в соответствии с условиями. Пока что мы записывали команды (выражения в C и Javascript) просто одна за одной, и ещё организовывали их в функции.

И в C, и Javascript существует конструкция `if`, который направляет выполнение по одному из нескольких путей в зависимости от результата вычисления какого-либо выражения (есть ещё switch/case, но пока мы о нём не будем) — а также его сокращённая форма, с вопросом и двоеточием.

Выглядит она так в полной форме (одинаково и в том, и в другом языке), количество блоков `else if` может быть неограниченным (в том числе и 0), но `else` максимум один.

    if (какое_то условие) {
       выражение;
       выражение;
       ...
    } else if (другое условие) {
       выражение;
       выражение;
       ...
    } else {
       выражение;
       выражение;
       ...
    }

Работает тоже очень просто — если результат вычисления выражения в скобках `if` истинный (о том, какой результат считается истинным, мы поговорим позже), выполняется блок кода сразу за `if`. Иначе проверяется условие в `else if`, если оно истинно — выполняется этот блок кода, если нет — переходится к следующему `else if`, и т.д. Если `else if` закончились и ни одно условие не сработало, то выполняется блок кода, который находится после `else` (если он есть).

*– происходят ли какие-то проверки насчет выражений в else if'ах, если уже первое условие выполнится?*
*– Нет. Они даже не будут вычисляться.*
*– но хотя бы синтаксически они должны быть корректные?*
*– Конечно, иначе код не скомпилируется.*

Теперь немного о грустном. В приличных языках программирования есть так называемые логические типы данных, которые могут принимать только два значения, истинное или ложное. Выражения, которые могут стоять в условии `if`, могут вычисляться и принимать только эти значения. Например, `2 * 2 == 4` — это истина, а `5 < 3` это ложь. 

(Двойной знак равенства — это операция _сравнения_, в отличие от одинарного знака равенства, которое является _присваиванием_. Если знак равенства отвечает на вопрос, используйте двойной, а если вы хотите присвоить значение чему-нибудь, то одинарный. За этим нужно следить — перепутать легко, а последствия могут быть страшны.)

*– Если первое верное выражение выполнилось, что с ним дальше происходит?*
*– В смысле, первое условие истинно, и выполнился блок кода который сразу после if? Остальные блоки кода, если они есть, пропускаются, и дальнейшее выполнение кода идёт после окончания всей конструкции if (последней закрывающей фигурной скобки, к ней относящейся).*

Но: в C нет логических переменных. Так получилось. Вместо этого в условиях используются целые числа, при этом `0` считается ложью, а всё остальное (включая отрицательные числа) — истиной. Очень кстати неудобно.

Убедиться в этом несложно: можно написать в C такое выражение:

    int result = 6 > 5

(то есть: присвоить переменной `result` результат вычисления выражения `6 > 5`). Его можно распечатать как любое другое число. Получится `1` («истина», то есть). Можете попробовать.

В Javascript же логические значения вроде есть... например,

    let result = 6 > 5

присвоит переменной `result` значение `true` (истина; а `false` это ложь, это зарезервированные ключевые слова). Казалось бы, всё хорошо. Но! Неведомо зачем Javascript также понимает в условии `if` и числа, интерпретируя их так же как C. А ещё там есть `undefined`. Что создаёт ВЕЛИКОЕ МНОЖЕСТВО проблем, которых не было бы, если бы авторы языка были бы тогда немного более внимательны. (А сейчас что-то менять уже поздно, иначе перестанет работать старый код).

Проверки условий можно комбинировать с помощью так называемых булевых (логических) операций. Они тоже одинаково записываются в двух языках, и выглядят так:

    a && b
— это логическое И (AND), выражение верно, только если оба условия a и b верны одновременно;

    a || b
— это логическое ИЛИ (OR), выражение верно, если хотя бы одно из условий a или b верно;

    !a
— это логическое отрицание (NOT), выражение верно, если условие a неверно.

Операторы `&&` и `||` имеют особенность: в случае с `(a && b)` если вычисленное значение `a` ложно, то `b` уже не вычисляется (потому что в любом случае результат известен — ложь). Обратно, когда мы вычисляем `(c || d)`, если `c` истинно, то `d` уже не вычисляется, так как уже понятно, что результат — истина. Это имеет значение, когда в результате вычисления `a` или `b` происходит что-то ещё (побочные эффекты).

Логические операторы, то есть `&&`, `||` и `!`, можно комбинировать в длинные выражения. У операторов при этом есть приоритет, так же как в арифметических выражениях сначала мы считаем умножение, а потом сложение (`2 + 2 * 2` будет 6, а не 8).

Соответственно, у отрицания самый высший приоритет, у логического И — средний, и самый низкий у логического ИЛИ.

*– для !a какие-то скобки вокруг a нужны?*
*– нет (нужны только если a это сложное выражение)*

Как и в случае с арифметикой, приоритет операций можно переобозначить скобками.

*– ну это вопрос приоритетов — у ! он самый высокий?*
*– да*

Операции сравнения, которыми можно сравнивать числа: `>`, `>=`, `<`, `<=`, `==`, `!=` (больше, больше или равно, меньше, меньше или равно, строго равно, строго не равно).

Как проверить, что значение переменной лежит в интервале? Например, "0 < x < 10" (так не работает).

Нужно одновременно проверить два условия:

    x > 0 && x < 10

На этом месте полагается давать кучу упражнений на раскрытие скобок, таблицы истинности, правила де Моргана, нормализацию и прочую скучную и нудную ерунду. Но у меня не было времени их написать.

Поэтому вместо этого мы будем рисовать остальную сову (а упражнения будут завтра).

### Практика 2.7 (Расчет BMI)

Написать программу на C (на джаваскрипте примерно то же самое, только читать значения из пользовательского ввода сложнее — поэтому на нём не надо), которая:

* запрашивает у пользователя его рост и вес с помощью функции `scanf` (как ей пользоваться, посмотрите в гугле);

* вычисляет его/её индекс массы тела (формулу посмотрите в гугле, вычисление сделайте отдельной функцией);

* если индекс массы тела ниже нижней границы нормы, выведите сообщение, что он низкий, если выше верхней границы нормы — выведите сообщение, что он высокий, если в пределах нормы — выведите сообщение, что в пределах нормы.

Значения границ «нормы» возьмите для своего пола в гугле или напишите какие вам интересны. Задание со звёздочкой — спросить у пользователя также пол, и использовать значения интервала «нормы» в соответствии с ним.

Редакция напоминает, что BMI не является разумной метрикой «красоты» или «здоровья», упражнение не несёт никакого нормативного смысла кроме обучающего, если вас триггерит использование BMI — можно придумать что-нибудь ещё. 🙂

Обратите внимание: в функции, которая вычисляет значение индекса массы тела, и в переменной, которой присваивается результат, должен быть тип `float`.

Результат закоммитить в гитхаб и показать мне 🙂

Я рекомендую сначала сделать для какого-то одного пола 🙂 Программы пишутся от простого к сложному.

*– При вычислении один тип превратится в другой?*
*– И аргументы тоже. Про конверсию типов я тоже забыл рассказать, конечно. `float` это тип для действительных чисел (с плавающей точкой). То есть дробных. Читается/печатается в `scanf` и `printf` он шаблоном `%f` (а не `%d`).*

Про ограничения точности, проблемы с арифметикой плавающей точки и прочих безднах тоже придётся рассказать в следующий раз.

Примечание из чата:

    > let result = (!1) == 2 undefined > result false

*В связи с этим есть трюк: если вы получаете какое-то значение откуда-то, и дальше планируете использовать его как логическое, используйте его не как есть, а как `!!a` — это будет простое и понятное булевское значение, а не что угодно.*

## S02E06. Рекурсия

Итак, на данный момент мы все умеем писать функции, вызывать функции, и выделять в функции логически обособленные куски кода. Некоторые также догадываются, что чистые функции предпочтительнее нечистых, и если можно отделять вычисления от эффектов, то лучше это делать (например, в прошлом задании вычислять BMI лучше отдельной функцией, а печатать его в main, или создать специальную функцию для печати).

Внутри одной функции можно вызвать другую, а внутри другой — третью, это тоже понятно. В конце концов, код и состоит из мешанины подобных вызовов. Вопрос, который на этом этапе должен всех интересовать — это "может ли функция вызвать саму себя?" Ну конечно может! Это явление и называется "рекурсия".

На первый взгляд кажется, что если функция вызывает сама себя, то это будет происходить до бесконечности. Так может быть, и даже у такого простейшего варианта рекурсии есть польза.

### Практика 2.8. У попа была собака

Напишите программу, которая с помощью рекурсии, то есть вызова функцией самой себя, выводит на экран стихотворение "у попа была собака" на всю свою бесконечную длину (когда надоест, прерывать исполнение программы можно по `Ctrl-C`). То есть примерно так:

    у попа была собака, он её любил
    она съела кусок мяса, он её убил
    в землю закопал
    и надпись написал, что у попа была собака, он её любил
    она съела кусок мяса, он её убил
    в землю закопал
    и надпись написал, что у попа была собака, он её любил
    ...

(Обратите внимание, какие из строк должны заканчиваться переводом строки, то есть символами `\n`. Разбивать на чистые и нечистые функции здесь не надо, функция должна просто печатать текст.)

Бесконечно исполняемые функции имеют ограниченное применение, поэтому обычно в рекурсивных функциях Яве есть условие ограниченияе. Например, если аргумент равен нулю — выйти из функции, в противном случае сделать что-то и вызвать саму себя с аргументом, уменьшенным на единицу. Таким образом можно писать интересные алгоритмы. 

### Практика 2.9. Пиво

Написать программу, печатающую стихотворение "99 bottles of beer on the wall" — как оно выглядит можно посмотреть здесь: https://en.wikipedia.org/wiki/99_Bottles_of_Beer (на этот раз программа должна после вывода стихотворения завершить работу).

А именно:

    99 bottles of beer on the wall, 99 bottles of beer.
    Take one down, pass it around, 98 bottles of beer on the wall...
    98 bottles of beer on the wall, 98 bottles of beer.
    Take one down, pass it around, 97 bottles of beer on the wall...
    97 bottles of beer on the wall, 97 bottles of beer.
    Take one down, pass it around, 96 bottles of beer on the wall...
    ...
    No more bottles of beer on the wall, no more bottles of beer.
    We've taken them down and passed them around; now we're drunk and passed out!
    Wikipedia 99 Bottles of Beer - Wikipedia

Задания можно выполнять на С или на Javascript, как вам больше нравится (или одно на одном, другое на другом).

*– Язык не накладывает ограничений на глубину рекурсии?*
*– Стек может кончиться, но есть возможность писать код так, чтобы этого не произошло (tail call optimization). Об этом расскажу после того как все сделают эти задания.*

## S02E07. Рекурсия. Продолжение: способ мыслить рекурсивно

Как мыслить рекурсивно: патентованный метод, тайненькое знаньице! Чему учат в университете на факультетах computer science, но почему-то никто не пишет в книжках.

Итак — для очень многих часто встречающихся задач в программировании можно придумать изящный рекурсивный алгоритм. Делается это так (точно так же работает математическая индукция):

1) возьмите примитивный, вырожденный вариант проблемы. Если нужно сделать что-то со строкой — как будет выглядеть эта операция для пустой строки? А для строки для одного символа? Из двух?

2) придумайте, как свести задачу для n+1 элементов к задаче из n элементов, и выразите первое через второе.

3) Напишите рекурсивную функцию, которая делает что-то для n элементов (что вы выяснили в пункте 2) и вызывает саму себя для n-1 элементов (в конце концов она добирается до вырожденного варианта из пункта 1, который вы определили заранее).

Например, любимая задача на интервью: нужно инвертировать строку, то есть из `abcde` сделать `edcba`. Записываем:

* Для пустой строки решение — пустая строка
* Для строки из одного символа решение — эта же строка
* Для строки из двух символов решение — поменять символы местами
* Для строки из n символов решение — отсечь первый символ, инвертировать остаток строки вызовом функции для n-1 символов, приставить к результату отсечённый символ последним. То есть: 

    reverse (“abc”) = reverse(“bc”) + “a” = “cb” + “a” = “cba”

Методом пристального всматривания можно заметить, что промежуточные пункты для одного и двух символов лишние: 

Для одного символа идея для n символов тоже работает
    reverse("a") = reverse("") + "a" = "a"

Равно и для двух: 
    reverse("ab") = reverse("b") + "a" = "ba"

Следовательно, в функции достаточно записать варианты для нуля и n символов. 

### Практика 2.10: инвертирование строки

Так и сделаем! (На джаваскрипте, потому что C будет нас отвлекать ненужными деталями). Для этого нужно знать (или посмотреть в гугле, что я советую сделать в любом случае), что: 

* "Взять символ номер n из строки" в джаваскрипте делается так же, как доступ к элементу любого массива: `some_string[n]`, где нумерация начинается с нуля. Первый символ будет `some_string[0]`;

* "Взять остаток строки кроме первых n символов" - это `string.substr(n)`, на этот раз _количество_ символов начинается с единицы;

* "Остаток строки без первого символа" это `some_string.substr(1)`;

* "Узнать длину строки" — `some_string.length`.

Остаётся дословно записать код:

    function reverse(string) {
        if (string.length == 0) {
            return string
        } else {
            return reverse(string.substr(1)) + string[0]
        }
    }

Проверьте, должно работать! (Это не очень оптимальный вариант, но разбором почему это так, мы займёмся в следующий раз — его легко переделать в оптимальный. Для наших целей его вполне достаточно). На всякий случай напоминаю, что проверить можно так:

    console.log(reverse("abcdefghi"))


### Практика 2.11: проверка на палиндромность

Напишите таким же способом функцию, которая проверяет, является ли её аргумент (строка) палиндромом, то есть читается так же слева направо, как и справа налево (если является, возвращает `true`, если не является, `false`).

То есть, например, `abcdcba` — палиндром, `aaaaa` — тоже, `abccba` — тоже, а `abcabc` — нет.

ВНИМАНИЕ! Есть большое искушение свести задачу к предыдущей и тупо сравнить строку с её инверсией. Такое решение засчитываться не будет — постройте функцию с нуля, воспользовавшись приведённой аргументацией.

### Практика 2.12: регистронезависимая проверка на палиндромность 

Напишите функцию, которая проверяет строки на палиндромность так, как это принято на самом деле — игнорируя регистр, пробелы и знаки препинания. Например, is_palindrome("Madam, I'm Adam") должно возвращать true. Найдите в гугле, как сравнивать два символа, игнорируя регистр; как пропускать пробелы и знаки препинания, вы должны догадаться сами.

Задание, если вы раньше такого не делали, сложное — поэтому на его выполнение (и на то чтобы догнать курс) вам даётся два дня, завтра ничего не будет. И не стесняйтесь спрашивать, если не получается!

## S02E08. Типы и структуры данных

Как мы уже говорили где-то на предыдущих лекциях, все данные в памяти компьютера представлены последовательностями байтов. В принципе, и в таком виде с ними можно работать, и иногда приходится. Но в большинстве языков программирования информация собирается из типов данных (**value types**), организованных в структуры данных (**data structures**) — а уже потом, на этапе компиляции или интерпретации, они отображаются в последовательности байтов в памяти (к которым часто даже нет прямого доступа).

### Примитивы

Элементарные типы данных называются **"примитивы"**. В разных языках программирования есть разные представления о том, что считать примитивом. Например, в C их очень много (и каждый может нести несколько названий, что запутывает), но вообще примитивные типы C - это либо разного рода числа, либо указатели. Примитивного типа "строка" в C нет, строка, как мы помним, это последовательность ASCII (или Unicode)-кодов, заканчивающаяся байтом `00`. Нет и логических типов. Только числа (целые и дробные, точнее, с плавающей точкой), и адреса в памяти. Благодаря такому минимализму, компиляторы C существуют для чего угодно, хоть для часов и холодильников.

Про числа вы знаете (более подробно мы о них поговорим позднее), а указатель — это «адрес в памяти», ссылка на какое-то другое значение (сопровождаемая в коде — но не в памяти — информацией о том, что это такое может быть).

В Javascript типизация слабая — одно и то же значение вроде `"1.2"` в разных контекстах может быть интерпретировано и как строка, и как число (что создаёт немало проблем). Но всё-таки примитивные типы есть и там, хотя они и не подразделяются на бесчисленные подкатегории как в C (где одних числовых типов больше десятка). Зато в Javascript — не одни числа, а вот что:

* **Логический тип (Boolean)** — содержит только два значения, true и false. Операции сравнения, например, выдают результатом именно его;

* **Неопределённый тип (Undefined)** — если переменную просто определить, но не задать сразу её значение, оно будет именно таковым. Существует ровно одно значение типа Undefined — это undefined. :) Его любой программист на джаваскрипте видит часто;

* **Числовой тип (Number)**. В отличие от C, числа в Javascript это "просто числа", а именно все числа — это 64-битные дробные числа с плавающей точкой. Про то, как устроено представление таких чисел, мы расскажем позднее, а пока упомянем, что это числа в двоичном представлении, вычисления с которыми создают небольшие погрешности в десятичном представлении. Поэтому нужно быть очень осторожными, сравнивая их. Например, запустите REPL node.js и проверьте там результат выражения: `(0.2 * 0.2) == 0.04` ну и просто `0.2 * 0.2`. Такие дела;

* **Строковый тип  (String)**. «Просто строки», последовательности «текстовых символов» неопределённой длины. Худо-бедно в джаваскрипте поддерживается юникод, с разной степенью смеха. Можно, например, попробовать операции смены регистра `string.toUpperCase` / `string.toLowerCase` для строки с вашими любимыми эмодзи.

Ещё в джаваскрипте есть примитивные типы **Null** («определённо пустое значение», в отличие от неопределённого undefined) и **Symbol** (уникальная строка) — последний новый и применяется редко. Больше примитивных типов в этом языке нет, все остальные типы — составные.


*Вопрос: почему ((0.2 * 0.2) == 0.04) считает как false?*

*Ответ: потому что компьютер считает дробные числа двоичной, а не десятичной арифметикой. В ней хорошо представляются двоичные дроби со знаменателем, кратным степени двойки (например, 1/4 или 1/512); привычные нам десятичные дроби можно представить лишь приближённо.*

*Это очень плохо; хотя сейчас можно было бы уже исправить ситуацию и сделать нормальные десятичные дроби примитивом, всем лень. Поэтому пока нужно запомнить, что сравнивать нецелые числа напрямую (кроме редких исключений, когда вы точно знаете что делаете — а пока вы не знаете) — нельзя. :((*


Функции в джаваскрипте — тоже тип данных, который можно считать примитивным. Функции можно не только вызывать, но и присваивать переменным и передавать аргументами (а также функция может возвращать другую функцию), что бывает очень полезно. 

Сейчас дам ссылку на интересную статью Спольски про это:

[Can Your Programming Language Do This?](https://www.joelonsoftware.com/2006/08/01/can-your-programming-language-do-this/)

(рекомендую почитать — как часть лекционного материала)

В C есть тип «указатель на функцию», предназначенный для того же самого.


*Вопрос: а он по сути тоже "адрес в памяти", начиная с которого идет какой-то код, или это абстракция?*

*Ответ: да, по большому счёту так.*


Тут нужно сделать интерлюдию — сказать, что языки программирования разделяются по уровню типизации.

### Уровни типизации

Типизация бывает слабая или сильная, а также статическая или динамическая.

Например, у C статическая и слабая типизация, а у Javascript — динамическая и слабая.

Сильная типизация означает, что значение одного типа не может быть проинтерпретировано как значение другого типа без явных преобразований — а слабая, соответственно, что может.

Как в C, так и в Javascript, такая операция возможна без особых ухищрений. Если же результат такой операции не очень имеет смысл, программа выдаст ошибку в процессе выполнения (а компилятор вам про неё не сообщит, поэтому искать такие ошибки бывает очень увлекательно).

Например, попробуйте умножить в Javascript строку на какое-нибудь число. Эта операция возможна, и компилятор не пожалуется! Результатом будет NaN (not a number — специальное псевдо-число, зарезервированное за результатами некоторых арифметических операций, вроде квадратного корня из минус единицы за неимением комплексных чисел). В общем, бардак.

В языках с сильной типизацией такие вещи невозможны, поэтому многие ошибки удаётся отловить раньше. Насколько раньше — это решается в дилемме "статическая/динамическая".

В C типизация статическая, то есть при объявлении переменных, декларировании аргументов функции и того, что она возвращает, нужно обязательно сразу указывать их тип (вроде `int i = 42` или `char* s = "Hello!"`).

Это помогает: после этого переменной типа int уже нельзя присвоить строку, и наоборот (а в Javascript пожалуйста).

В Javascript с динамической типизацией тип переменных нигде в коде не указывается, и любой переменной может быть присвоено любое значение, и любая функция тоже может возвращать всё что угодно. Допустить ошибки в таком языке проще, а отлаживать код соответственно сложнее.

Наиболее известный язык с сильной и статической типизацией — Java. Он многословный, но зато позволяет избежать целого класса ошибок, распространённых в языках без статической/сильной типизации. Но Java это такой "необходимый минимум", есть сильно и статически типизированные языки с гораздо более широкими возможностями (например, Rust, Scala и Haskell). Про них ходит шутка "если программа скомпилировалась, она работает" — и часто это действительно так, хотя добиться этой компиляции бывает непросто.

Языки с сильной, но динамической типизацией редки, но существуют (например, Smalltalk).

### Структуры данных 

Одними примитивными типами программировать неудобно, поэтому существуют составные типы, они же структуры данных (последний термин более низкоуровневый, обычно подразумевает их внутреннее устройство).

Почти во всех языках программирования существуют типы-**последовательности** (отличающиеся внутренним устройством: это могут быть связанные списки, массивы и более экзотические конструкции, например множества) и типы-**словари** (деревья, хэш-таблицы, и другие). Ещё бывают **tuples**, или **структуры** — жёстко заданные совокупности примитивных типов (в отличие от словарей, в которых содержимое можно задавать динамически в процессе выполнения программы).

Например, `int[]` — это тип-последовательность "массив целых чисел" в C. Поскольку память в C выделяется вручную, нужно сразу указывать его размер при инициализации, что тоже приводит к множеству забавных ошибок. В Javascript есть встроенный тип "массив чего угодно", например, `[]` это пустой массив, а `[1,2,3,4,5]` это массив с числами.

С последовательностями, массивами в том числе, возможны какие-то стандартные операции. Можно узнать его длину (в C и это нетривиально, но несложно). Существует индексирование, то есть выбор элемента по его порядковому номеру (начиная с нуля). Бывает возможным разбить последовательность на несколько по какому-то критерию, или скопировать одну в другую.

Массив отличается от связанного списка тем, что в массиве значения всегда находятся друг рядом с другом в памяти, а в связанном списке — не обязательно, там просто каждый элемент указывает на следующий (бывает двусвязный список, там и на предыдущий). Это влияет на скорость операций: например, в большой массив сложно вставить элемент в середину, а в большой связанный список это сделать тривиально. Зато в массивах можно очень быстро получить элемент по его индексу, а в связанном списке для этого придётся проходить элементы один за другим, пока не достигнешь нужного.

(В стандартной библиотеке как Javascript, так и C связанных списков нет, только массивы. При этом в C они ещё и не динамические, то есть добавлять/удалять элементы нельзя — можно только создать массив побольше-поменьше и скопировать туда элементы из предыдущего. Но всё это и многое другое есть в сторонних библиотеках).

Я тут решил попробовать давать меньше материала, но каждый день, так что про словари (и объекты в JS) будет уже завтра. А на сегодня небольшое задание:

### Задание. Игры с типами

Посмотрите и попробуйте, как в C и Javascript (начните с Javascript) можно:

* создать массив чисел;
* создать массив строк;
* узнать длину массива;
* получить элемент по индексу;
* получить последний элемент;

и только в javascript:

* добавить элемент в начало;
* добавить элемент в конец;
* удалить элемент по индексу;
* объединить два массива в один;
* применить функцию ко всем элементам массива и получить новый той же длины.

### Ссылка на примитивы языка C

Да, про примитивные типы в C я забыл рассказать, так как там очень много числовых типов разных размеров, но их можно посмотреть например тут: [https://en.wikipedia.org/wiki/C_data_types](https://en.wikipedia.org/wiki/C_data_types)

## S02E09. Вводная лекция о компьютерной архитектуре

Как многим известно, компьютеры в современном их понимании придумал в 1936 году Алан Тьюринг. Если точнее, Тьюринг придумал математическую модель вычислений (машину Тьюринга) — некое очень простое абстрактное устройство, с помощью которого можно делать (с некоторыми ухищрениями) вычисления произвольной сложности. Устройство выглядит так:

* бесконечная лента ячеек, в каждой их которых может находиться символ из произвольного алфавита. По умолчанию в каждой ячейке находится специальный "пустой" символ. Минимальное количество символов, удовлетворяющее этим критериям — два, например "0" и "1". Но в принципе они могут быть какими угодно.

* _головка_ (воображаемое устройство, которое умеет читать и записывать символы на ленте, а также передвигаться на шаг влево или вправо)

* регистр состояний (отдельная ячейка, в которой может находится символ из отдельного алфавита состояний. Для сколько-нибудь интересных алгоритмов двумя состояниями уже не обойтись, обычно их больше).

* таблица инструкций. Это чистая функция, которая для каждого сочетания "символ на ленте под головкой" + "текущее состояние" выдаёт: символ, который следует записать на ленту вместо текущего, новое состояние, которое следует положить в регистр состояний, и один из вариантов: передвинуть головку влево, передвинуть головку вправо, или остаться на месте.

Машина Тьюринга последовательно:

* читает символ из текущего положения головки на ленте (например, 1)
* читает состояние из регистра состояний (например, A)
* смотрит в таблицу инструкций и видит, есть ли там запись для символа 1 и состояния A; например, такая: 1,A -> 0,B,R. Если есть, записывает в ячейку под головку новый символ (0), в регистр состояний новое состояние (B), и двигает головку в нужном направлении (R, направо). Если в таблице инструкций записи не нашлось, машина останавливается.

С помощью этого нехитрого воображаемого устройства Тьюринг доказал следующее:

1. Хитро подобрав таблицу инструкций, можно произвести _любое_ математическое вычисление с любой произвольной точностью (интерпретируя получившуюся последовательность символов на ленте как результат, например как двоичное число). Умножение, деление, синусы-косинусы, логарифмы, матрицы, всё что угодно.

2. Не существует способа определить заранее даже то, остановится ли машина в конечном итоге или будет работать вечно, исполняя инструкции по кругу — не говоря уже о том, даст ли набор инструкций правильный результат.

Все компьютеры, от древних больших ламповых до ваших мобильников, работают примерно так же, как машина Тьюринга, с некоторыми несущественными оптимизациями. Просто они делают это _очень_ быстро. Лента — это память, головка и таблица инструкций — это процессор, регистр состояния — часть процессора, так и называется "регистр" (регистров может быть много. Но не очень — обычно их несколько десятков; так работать удобнее, чем с одним).

Заметим, что в оригинальной машине Тьюринга таблица инструкций находится отдельно от ленты с символами, и неизменна. Такое положение дел существует в некоторых микроконтроллерах (встраиваемых компьютерах) — это называется **"гарвардская архитектура"**. Но сам же Тьюринг показал, а после него фон Нейман развил идею, что таблицу инструкций можно изначально хранить на самой же ленте символов. Почти все компьютеры работают именно таким образом, это называется **"фон-неймановская архитектура"**.

Важная концепция: **"тьюринговская универсальность"**. Любая система, которая физически или математически реализует возможность построить машину Тьюринга, может выполнять любые вычисления, разница только в скорости работы. Из этого важное следствие:

Если какую-то задачу можно решить на одном языке программирования, её можно решить и на любом другом. 

Все языки программирования эквивалентны друг другу в "мощности", то есть бесконечном множестве решаемых ими задач. Они различаются только производительностью, удобством работы, и приспособленностью для тех или иных классов решаемых проблем.

Современные настоящие процессоры отличаются от базовой машины Тьюринга тем, что они:

* работают только с двоичными числами, из ноликов и единиц;
* содержат несколько регистров, а не один;
* реализуют с этими регистрами некоторые базовые арифметические действия, а не только перезапись по таблице инструкций. Например, "сложить числа в регистрах A и B, записать результат в регистр A";
* максимальный размер чисел, с которыми работает процессор, ограничен количеством "бит" в регистрах. Современные процессоры, как правило, 64-битные, следовательно, максимальный размер чисел, с которыми они могут работать за один раз — 2 в 64-й степени, а именно 18446744073709551616. Для чисел больше чем это нужно придумывать специальные алгоритмы, осуществляющие арифметические операции последовательно за несколько действий;
* "головка" может двигаться не только на шаг влево и шаг вправо, а в любое место за раз (то есть процессор может читать в регистры и записывать из регистров числа в любое место в памяти, или, как говорят, "по любому адресу");
* по наступлению некоторых внешних событий (например, нажатию клавиши на клавиатуре) процессор может прекращать делать то, что он делал, и выполнить специальную последовательность инструкций, что-то делающую с этим событием (например, записывающую в специальное место в памяти число, соответствующее нажатой клавише). Эта процедура называется "прерывание";
* если процессор записывает числа в специально отведённую область памяти (она называется "видеопамять"), они интерпретируются как пиксели на экране. Например, числа 255, 255, 0, записанные по определённому адресу, закодируют жёлтый цвет, и в соответствующей части монитора загорится жёлтая точка. Подобным же образом устроено взаимодействие и с другими внешними устройствами (например, колонками, издающими звук).

Всё, больше толком ничего процессоры делать не умеют. Это весь компьютер. Он именно настолько тупой.

Писать программу, реализующую машину Тьюринга, мы не будем — это несложно и познавательно, но решать задачи с её помощью довольно нудно. Зато мы будем писать инструкции непосредственно для процессора, который их будет выполнять, не отвлекаясь ни на что другое. Такие инструкции называются "машинный код", а если операции процессора закодировать не числами, которыми он понимает, а текстовыми мнемониками, пригодными для понимания человеком — это будет называться "ассемблерный код", или просто "ассемблер".

Им-то мы завтра и займёмся.

## S02E10. Ассемблер x86, загрузка ОС

### Необходимое ПО

Для работы всем понадобится эмулятор компьютера **QEMU**; пожалуйста, установите его для своей операционной системы (на сайте QEMU описана установка для Linux, Mac и Windows).

Ещё нам понадобится собственно ассемблер — установите **nasm** из вашего менеджера пакетов.

(Как пользоваться менеджерами пакетов, я объяснял на первом модуле — это brew для macOS, apt для Ubuntu/Linux, и pacman/msys2 для Windows.)

### Ассемблер x86

Существуют множество процессоров и их архитектур (а существовало ещё больше), но по ряду причин в 2019 году мы можем столкнуться на практике с двумя: **x86** и **ARM**. Первая придумана американской компанией Intel, и на ней работают процессоры в ваших десктопах, ноутбуках и серверах. Вторая была создана невесть когда в Великобритании, и из-за цепочки случайностей получила распространение почти во всех нынешних мобильных устройствах (телефонах и планшетах) — как c iOS, так и с Android. Обе архитектуры не самые изящные, и несут на себе огромный багаж обратной совместимости, но так получилось. Тысячи цветов не расцвели. 

Мы будем писать на ассемблере x86, который описывает машинный код, понимаемый процессорами Intel.

Чтобы нашу чистоту разума ничего не замутнило, мы отбросим все огромные культурные слои, предоставляемые операционной системой, библиотеками, шеллами, браузером и т.п., и попробуем написать код, который будет исполняться процессором непосредственно и эксклюзивно. Иными словами, перезагрузимся без операционной системы. Не то чтобы мы много успеем, но именно с этого начинается написание ОС, и когда-то Линус Торвальдс и Билл Гейтс сидели над кодом загрузчика и дописывали туда ассемблерные команды, так же, как это будете делать сейчас вы.

Поскольку загрузить современные компьютеры не так-то просто, я попросил вас поставить эмулятор QEMU (факультативно потом вы сможете записать получившийся под на флешку и попробовать загрузиться на настоящем компьютере, но это нетривиально и может не получиться по ряду причин). Ещё нам понадобится собственно ассемблер — установите nasm из вашего менеджера пакетов.

Итак, как многие знают, x86-компьютеры оснащены такой штукой как BIOS (про EFI я сейчас не буду говорить, это то же самое только хуже и монстроподобнее). **BIOS** — это небольшая встроенная (то есть всегда присутствуюшая) программка, которая предоставляет очень простой API к устройствам компьютера (на уровне "поставить сюда символ", "зажечь пиксель", и "прочитать с диска байт по такому-то смещению"), и умеет загружать первые 512 байт кода с дисков (а также флешек и других носителей). Эти 512 байт называются "загрузочным сектором", и в основном служат для того чтобы найти на диске ещё код и начать его выполнять (передать управление операционной системе). Но у нас ОС не будет, мы будем писать команды на ассемблере прямо туда. 512 байт это не так и мало.

Чтобы проверить, что перед нами на диске именно бут-сектор, BIOS проверяет, что байты 511 и 512 содержат значения `55` и `aa` соответственно. Случайно они вряд ли там окажутся, а если их туда записали намеренно — значит, давайте попробуем выполнить код всего бутсектора целиком.

Процессор исполняет **машинный код** — числа, которые он интепретирует как команды и аргументы. Страшную ужасную таблицу, какое число какой команде соответствует, можно посмотреть например здесь: http://ref.x86asm.net/coder32.html. В незапамятные времена программисты так и писали программы, сверяясь с таблицей и вручную добавляя команды байт за байтом. Мы, понятно, этого делать не будем и будем писать на ассемблере — текстовом представлении команд процессора (и некоторых удобных средств управления вроде меток), которое потом транслируется в машинный код.

Напишем простейший дзен-бутсектор, который ничего не делает (зависает в бесконечном цикле). Для этого нам нужно:

1. Написать команду бесконечного цикла. Команда безусловного перехода в x86-ассемблере называется `jmp`, и если её аргументом дать адрес самой себя (или метку, чтобы ассемблер сам вычислил адрес), мы зациклимся.

2. Заполнить остальные байты бутсектора, кроме последних двух, чем угодно, например нулями.

3. Байты 511 и 512 заполнить 16-ричными числами `55` и `aa`. Для этого в ассемблере есть команды вставления констант — по причине того, что байты в числах в Intel-архитектуре идут наоборот (как я объяснял в первом модуле), это число будет 0xaa55 (шестнадцатиричное). Константа соответствущего размера в ассемблере обычно обозначается `dw`.

Так и запишем. Создаём файлик boot.asm, и пишем там следующее:

    loop:
        jmp loop

    times 510-($-$$) db 0
    dw 0xaa55

(ужасная строка `times` высчитывает, сколько осталось до 510 байт, то есть 512 без последних, и заполняет их нулями)

Транслируем в машинный код: `nasm -f bin boot.asm`,
убеждаемся, что получившийся файлик занимает ровно 512 байт,
и загружаем виртуальный компьютер:

    qemu-system-x86_64 boot

(boot это ваш файлик с машинным кодом бутсектора, а команда `qemu` у вас может выглядеть иначе, посмотрите как именно).

Если всё прошло успешно, виртуальный компьютер напишет, что он загружается с диска, и зависнет. Так и должно быть!

Если всё получилось, ваша задача написать в бут-секторе `hello world` (поскольку делать это придётся посимвольно, обойдёмся просто `Hello`). Сейчас расскажу то, что для этого нужно знать.

Как мы знаем из прошлого раза, у процессора есть регистры (места, куда можно записывать числа, ну и буквы в байтовом представлении тоже), а также прерывания.

Команда, которая перемещает значения из одного места в другое (а точнее, копирует), называется `mov`. 

выглядит она так:

    mov (куда), (что)

например, положить в регистр ah нулевой байт это:

    mov ah, 0x00

а положить в регистр `al` байт, соответствующий букве 'H', это:

    mov al, 'H'

(немного про регистры. В самом начале истории Intel они были 8-битными, вмещали 1 байт и  назывались, видимо, a, b, c и d. Уже почти сразу они стали 16-битными (вмещать 2 байта) и называться ax, bx, cx и dx (есть и другие) при этом "старший" байт каждого из них обозначется например как ah, а "младший" — al.)

Потом компьютеры стали 32-битными (регистры eax, ebx...), а потом и 64-битными (rax, rbx, ...) Нам пока такие большие числа не нужны. :)

Итак, чтобы выводить буковки на экран, в байте регистра ah должно находиться магическое значение 0x0e (режим терминала). 
А потом можно по очереди класть в регистр al байты буковок, и после каждой вызывать прерывание 10, которое говорит BIOS, что вот эту буковку надо вывести на экран. И так одну за одной.

Прерывания вызываются командой `int`, в нашем случае

    int 0x10

## ЗАДАНИЕ:

1. Написать бутсектор, который пишет на экран слово Hello (в гугл по возможности не смотреть).
2. Загрузиться с ним в qemu.

## S02E11. Указатели

Итак, в прошлый раз мы пописали немного на ассемблере и убедились, что это довольно утомительно. BIOS выводит информацию посимвольно, значения из памяти можно переносить в регистры максимум по несколько байт за раз, все алгоритмы нужно придумывать заново (даже число просто так не распечатаешь, нужно вручную придумывать алгоритм, который переводит числовое значение в последовательность ASCII-кодов, которые можно напечатать через BIOS, и из человеколюбия я не буду заставлять вас это делать). Хотя в принципе если кто склонен к некоторому мазохизму, то есть страдает жаждой познания, то продолжать ассемблерные опыты можно (и очень рекомендуется!) здесь: [http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf](http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf)

Вернёмся к C. Хотя многие справедливо называют C "таким продвинутым макроассемблером", намекая на его низкоуровневость — всё же он абстрагирует работу с памятью, вызовами функций и типами данных, потому что делать это совсем уж вручную ужасно надоедает. Например, аргументы функций и переменные внутри тела функции автоматически распихиваются компилятором по регистрам и стеку (такая выделенная область памяти, в которую можно запихивать значения из регистров один за другим, а потом доставать в обратном порядке по одному за раз; полезна, так как регистров мало и для всего не хватает, но работать с ним вручную на ассемблере опять же крайне утомительно).

Помимо регистров и констант, на ассемблере мы можем работать с памятью, указывая в качестве аргументов командам адреса памяти (смещения, куда можно записать / откуда прочитать значения). В C такой фокус тоже бывает необходим; чистые адреса в нём заменяются на *указатели.

Что такое указатель в C? Указатель это адрес в памяти, снабжённый сведениями о размере того, что там может находиться (просто одного значения, или одного элемента из нескольких). Само абсолютное значение адреса в памяти нам неинтересно, и, как правило, оно не имеет отношения к действительности (разве что их можно сравнить, чтобы узнать, не указывают ли два указателя на одно и то же место в памяти).

Указатель в C обозначается звёздочкой между типом и названием аргумента или переменной. Например, `int* some_var` — это переменная, содержащая указатель на значение типа `int`. Как вы уже знаете, любой массив в C — это указатель на первое из его значений, а строка — указатель на первый символ.

Разберём пример. Напишем в C (внутри функции main, с инклюдами, как положено) что-то в этом роде:

    int x = 1;
    int y = x;
    x = 5;
    printf("%d", y);

что выведется результатом?

(ответ: 1. Мы поменяли значение переменной `x`, но это не распространилось на значение переменной `y`, которая когда-то была равна `x`, но сейчас уже нет, так как значение `x` поменялось, а `y` нет.)

Как сделать так, чтобы если мы сказали, что `y` равно `x`, то так всегда и было? С помощью указателей.

(Напомним: объявляется указатель звёздочкой после типа переменной. Получить указатель на переменную можно поставив перед её именем символ `&`. Наоборот, имея указатель, можно его разыменовать, то есть получить лежащее по этому адресу значение, опять поставив перед ним звёздочку).

Вот так:

    int x = 1;
    int* y = &x;
    x = 5;
    printf("%d", *y);

(`y` теперь — указатель на значение типа `int`, сейчас указывает на значение переменной `x`. Когда значение `x` поменялось, указатель стал указывать на новое значение, его мы и напечатали. Будет напечатано значение 5).

Функции могут принимать указатели аргументами (такова, например, уже известная нам функция `scanf`, которая принимает указатель на переменную, куда нужно записать прочитанное из пользовательского ввода значение).

Интересно, что функция может изменить значение, находящееся по указателю (если только аргумент-указатель не объявлен с модификатором `const`, например `const int* argument` — тогда не может).

### ЗАДАНИЕ. Вывод ответа на главный вопрос вселенной (с помощью указателей). 

Напишите на C функцию возвращающую `void` (то есть ничего), принимающую аргументом указатель на значение типа `int` и умножающую его на два. В `main` объявите переменную `int` со значением `42`, вызовите вашу функцию с указателем на эту переменную, и распечатайте её значение после модификации.

### Продолжение. Указатели на функции

Указатели могут быть не только на переменные, но и на массивы (это мы знаем), на произвольные выделенные области памяти (об этом мы поговорим позже), на другие указатели (например, `char**`), и на функции. Последняя штука полезна, так как даёт возможность функциям принимать другие функции как аргументы и возвращать тоже функции, если надо.

Такова например присутствующая в `stdlib.h` функция `qsort`, которая может отсортировать массив чего угодно (хоть чисел, хоть структур, хоть строк и т.п). `qsort` принимает такие аргументы:

* указатель на сам массив;
* длину массива;
* размер элемента массива (для этого в C есть удобная конструкция `sizeof(тип)`, например `sizeof(int)` для целых чисел);
* указатель на функцию сравнения элементов массива — принимает два указателя на `void` (то есть любого типа, которые можно потом проинтерпретировать как нужный) и возвращает `-1`, `0` или `1` в зависимости от того, в каком порядке эти два значения расположены. Такая функция называется *"компаратор"*.

Например, чтобы отсортировать значения массива в прямом порядке, компаратор для значений `a`, `b` должен выдавать:

    если a < b: 1 (правильный порядок a и b)

    если a > b: -1 (неправильный порядок a и b)

    если a == b: 0 (всё равно в каком порядке равные a и b)

Компаратор позволяет сортировать не только по возрастанию-убыванию, но и в любом другом порядке. Он объясняет сортировочной функции, что именно мы имеем в виду под «порядком».

### ЗАДАНИЕ. Компаратор для сортировки в обратном порядке

Дан массив из 10 чисел, например:

    int array[10] = {3, 5, 1, 7, 2, 7, 6, 0, 8, 4}

Напишите функцию-компаратор для `qsort` для сортировки в _обратном_ порядке.

Поскольку функция принимает указатели на `void`, а нам нужны на `int`, их нужно проинтерпретировать как таковые (это называется *to cast*, по-русски говорят *«привести к типу такому-то»*, хотя кого мы обманываем, все так и говорят *«прокастовать»*): 

    int reverse_sorter(const void *first_arg, const void *second_arg) {
        int* first = (int*) first_arg;
        int* second = (int*) second_arg;

        /* здесь ваш код сравнения, возвращающий -1, 0 или 1 */

    }

(Обратите внимание, что компаратор принимает указатели, помеченные `const` — это сделано для того, чтобы он не смог поменять значения, находящиеся там).

Написав компаратор, вызовите с ним `qsort`, чтобы отсортировать массив в обратном порядке. Распечатайте результат.

Постарайтесь не искать в гугле «как пользоваться qsort», а попытаться разобраться самостоятельно.

### Дополнительное задание: как работает Quicksort

Прочитайте в википедии, как работает Quicksort (алгоритм сортировки, реализуемый функцией `qsort`). Довольно странный и интуитивно малопонятный алгоритм, но работает хорошо! Заодно прочитайте про `merge sort`, `insertion sort` и др. — чем они отличаются и как работают. Найдите все доступные алгоритмы сортировки в стандартной библиотеке C.

### Задание с Большой Звёздочкой

Попробуйте написать merge sort на C самостоятельно, с такими же принимаемыми аргументами. Это вот будет непросто, зато точно разберётесь! Кроме того, это стандартный вопрос на интервью в приличные места.
