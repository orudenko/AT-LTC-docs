## S02E01. Интерлюдия: форматы данных

Сегодня мы поговорим о способах представления информации компьютерами. Как мы все знаем, компьютеры внутри себя способны работать только с нулями и единицами; тем не менее, на экранах мы видим буковки, цифирки и картинки с котиками. Логичный вывод — компьютеры представляют котиков и тексты про них в качестве двоичных чисел, а как это происходит — мы сейчас разберём.

На заре теплоты и ламповости инженеры установили, что будет удобнее всего группировать нолики и единицы (биты) в группы по восемь штук (байты). Соответственно, когда компьютеры читают и записывают числа в память, они это делают с минимальной группой по 8 бит: от 00000000 до 11111111, или в десятичном представлении от 0 до 255. 

“Немало" — подумали инженеры (а компьютеры тогда придумывались в основном в США и возможно немножко в европейских странах с латинским алфавитом, ну может ещё иногда в СССР, где букв тоже немного), и решили поставить некоторые числа в соответствии с некоторыми буквами и символами. Букв в английском алфавите 26, берём большие и маленькие — значит, 52, да ещё 10 цифр, да знаки препинания, да управляющие команды — ура, точно влезает! Влезло даже в 7 бит (127 возможных значений), а восьмой оставили на будущее, и для поддержки других кодировок (в другие 127, например, можно засунуть русский алфавит). 

Эта таблица соответствий для первых 127 символов (их было несколько, но победила только одна) стала называться кодом ASCII: https://ru.wikipedia.org/wiki/ASCII.

Соответственно, все компьютеры, операционные системы и программы, понимающие что такое ASCII (а сейчас это почти все и везде) знают, что если речь идёт о тексте, то байт с числом 32 это пробел, а 107 — буква k, и т.д. Байты обычно записываются в шестнадцатеричной системе счисления, потому что так они удобно вмещаются в два символа, от 00 до FF, вместо десятичных от 0 до 255 (и арифметика больше похожа на двоичную). Поэтому обычно записывают байт, соответствующий пробелу, как 20, а букве k — 6B. Чтобы не путать системы счисления, шестнадцатеричные числа записывают как 0x6B, или 6Bh. Откуда взялся префикс 0x, это отдельная грустная история, которая доказывает что у программистов нет ни ума, ни фантазии (но все привыкли). 

Соответственно, строка `Hello, world!` видится компьютерам (и языкам программирования) как последовательность байт: 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21.

Всё бы ничего, но как же понять, где эта строка заканчивается? После неё в памяти могут идти и другие байты. Можно предложить несколько решений, и по ряду причин победило не лучшее из них.

Первое, очевидное решение: указать два адреса (места расположения) в памяти, где хранятся начало и конец строки. Программисты взбунтовались, как же так, это сколько лишней памяти тратится? Для 64-битного компьютера (который поэтому и называется 64-битным) адрес (это тоже число) занимает 64 бита, то есть 8 байт. И если содержимое строки "fuck" само по себе занимает 4 байта, то её начало и конец добавят ещё по 8, и так для каждой строки. 4 и 20 — есть разница? Память-то не резиновая, что бы ни думал Chrome по этому поводу. Поэтому такой метод распространения не получил.

Следующий вариант — указывать в начале каждой строки её длину. Например, `Hello, world! занимает 13 байтов, добавим число 13 (или в шестнадцатиричном представлении 0d) в начале:  0d, 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21, и научим программы, что сначала читаем из памяти длину строки, а потом столько байтов, сколько указано в длине. Это хороший метод, который и память экономит, и позволяет не тратить время на подсчёт длины и множество других операций, но так можно закодировать только строки длиной до 255 символов, по очевидным причинам. Для твиттера пойдёт (и то там уже 280), но для ЖЖ уже не очень. Два байта дают возможность кодировать строки до (256*256)-1=65535 символов в длину, но и этого может быть недостаточно, и кроме того, как договориться, в каких строках хватит одного байта для длины, а в каких нужно два? (Программисты, как известно, никогда не могут ни о чём договориться друг с другом). Поэтому и этот способ распространения не получил, хотя некоторые программы его используют.

Наконец, кто-то решил, что давайте поступим максимально тупо — просто конец каждой строки будем обозначать байтом 00, чтобы никто не догадался. Как программа видит 00 — так и считаем, что строка закончилась. На том и порешили, так теперь в большинстве языков, программ и операционных систем всё и происходит. Это создаёт множество проблем (стоит убрать нулевой байт откуда-нибудь, и программа спокойненько читает дальше память, которая ей не предназначена, а если вставить в строку нулевой байт специально, то тоже ничего хорошего не получится). Но такова селяви, живём теперь с этим.

Теперь вы знаете, что Hello, world! компьютер обычно видит как 48, 65, 6c, 6c, 6f, 2c, 20, 77, 6f, 72, 6c, 64, 21, 00. Ну или если переходить прямо к ноликам и единицам, то 01001000, 01100101, 01101100, 01101100, 01101111, 00101100, 00100000, 01110111, 01101111, 01110010, 01101100, 01100100, 00100001, 00000000

Для английского языка всё так и осталось; символы других языков представляются несколько сложнее. После дикого периода, когда одновременно существовало множество разных национальных кодировок (деды пугали, что на каждом сайте приходилось выбирать KOI-8, CP-1251 и какие-то другие ужасы), программисты придумали наконец универсальное решение: Unicode

У Unicode есть два слоя: абстрактное представление, и непосредственно способ кодирования. Абстрактное представление — это просто (сколь угодно большое) число, которому поставлен в соответствие почти каждый символ, который успело придумать человечество в разных естественных языках, а заодно псевдографику, математические символы, и даже эмодзи с какашкой: 💩. Он, кстати, находится в списке Unicode под номером 55357, или в шестнадцатеричном представлении — 1f4a9.

Это не означает, что мы можем просто так взять и записать число 1f4a9 где-нибудь (это займёт три байта — 01, f4, a9 — иногда в обратном порядке, потому что программисты не могут договориться даже об этом), и программа сразу поймёт, что имеется в виду именно этот эмодзи. Потому что как можно отличить его, допустим, от трёх разных символов, обозначаемых байтами 01, f4 и a9 по-отдельности?

В общем, после многочисленных бурных дискуссий, в результате которых родилось и погибло (но не до конца) множество промежуточных представлений Unicode, программисты родили более или менее универсальную кодировку UTF-8, которая теперь применяется почти везде (за некоторыми смешными исключениями, о которых я потом расскажу по просьбам комментирующих в личку). Устроена она так.

Все символы ASCII (латинский алфавит, цифры, управляющие последовательности, знаки препинания и немного псевдографики), как и раньше, кодируются одним байтом от 0 до 127, то есть от 00 до 7F.

Все символы, в списке Unicode обозначаемые номерами больше 7F, но меньше 7FF (с 80 по 2047), кодируются двумя байтами, по хитрому двоичному шаблону: 110xxxxx 10xxxxxx (вместо иксов вставляем биты двоичного представления номера символа). То есть когда компьютер видит байт, начинающийся в двоичном виде с 1, он знает, что речь точно идёт не о ASCII, а если он ещё и начинается со 110, то это первый байт из двух нужных для прочтения представления символа до 7FF. Русские буквы входят в эту область.

Соответственно, символы далее по списку кодируются двоичным шаблоном 1110xxxx 10xxxxxx 10xxxxxx (три байта; туда входят иероглифы и эмодзи), а ещё дальше -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx (четыре байта, там уж совсем экзотика). Больше четырёх байтов в UTF-8 сейчас не бывает, и последний символ, который можно так закодировать, имеет номер 10ffff (или в десятичном представлении - 1 114 111). Should be enough for everyone!

Разумеется, количество драмы после введения Unicode/UTF-8 ничуть не уменьшилось. Например, русская А и латинская A это один и тот же символ, или разные? Решили, что разные. А вот к примеру, 人 в японском языке и 人 в китайском? Решили, что один и тот же, потому что если каждый иероглиф в каждом языке обозначать разными способами, то вообще никакой памяти не хватит. Японцы страшно обиделись, разумеется.

Есть и другие проблемы: арабы с евреями пишут справа налево, но в строке могут встречаться цифры и латинские слова, которые слева направо. Для этого в Unicode есть управляющие последовательности смены направления чтения, которые отлично конфликтуют друг с другом и всем остальным и часто плохо работают

*—Если первый байт показывает значимое количество байтов в слове, зачем первые два бита 10 во втором и последующих байтах слова?*
*—Потому что если строка разобьётся на несколько частей в произвольном месте по байтам, так можно понять, с этого байта начинается символ или это продолжение какого-то.*

Также теперь размеры строк в памяти не соответствуют количеству символов, и тривиального способа определить размер utf8-строки самостоятельно не существует (помимо того что один символ занимает произвольное количество байт от 1 до 4, ещё есть диакритики, нормализация и чёрт знает что.) К счастью, авторы стандартных библиотек для распространённых языков программирования уже съели свою норму 💩, и теперь можно пользоваться библиотечными операциями для работы с Unicode почти везде.

Помимо строк, программисты придумали как кодировать что угодно. Картинки? Например, 4 байта на каждый пиксель, для уровней красного, синего, зелёного, и прозрачности (так это занимает очень много места, поэтому потом картинки сжимаются в джипеги или гифки хитромудрыми алгоритмами).

Звук? По два байта (то есть число от 0 до 65535) для значения амплитуды звуковой волны в каждый текущий момент времени, и так 48 тысяч раз в секунду (тоже немало места, и тоже очень сложные алгоритмы сжатия с потерями делают из этого mp3 — но сначала звук представляется именно в таком формате).

Команды машинного кода, которые понимает процессор — тоже записываются каким-то количеством байт (и тоже разным, чтобы программисты не скучали). Для процессоров Intel команда add, складывающая два числа, обозначается (в разных вариантах) байтами 00 или 01 или 02 или 03 или 05, а также иногда (не спрашивайте) 80 или 81.

К счастью, работать непосредственно с представлением в байтах нужно только на уровне системного программирования, а на высоком уровне можно вставлять эмодзи прямо в текст программы, или говорить библиотеке «а сделай этот звуковой файл чуть погромче». Но знать, с чем имеешь дело, всё равно нужно.

## S02E02. Git и Github. Системы контроля версий — от создателей Новая Папка(13)!

### Git: введение

(Предупреждение: моих скромных педагогических способностей может не хватить на то, чтобы адекватно научить всех пользоваться гитом. Рэндалл Монро, как всегда, рассказал о проблеме лучше меня: https://xkcd.com/1597/. Знание о том, что гит представляет ревизии в виде графа с указателями, никак не помогает лично мне научиться им хорошо пользоваться. Интерфейс командной строки гита ужасен и неинтуитивен, документация написана боевыми аутистами, а книги типа Pro Git тоже только запутывают ситуацию.

К сожалению, гиту нет альтернативы — у наиболее известного конкурента, Mercurial, хватает своих проблем, а кроме того у гита есть гитхаб — социальная сеть для программистов, где они вместе пишут код, иногда по работе, а иногда так, как будто других дел нет (альтернативы гитхабу недостойны упоминания). Затягивает. Вы уже все создали аккаунты на гитхабе, да?)

Сначала небольшая техническая заминка. Чтобы пользоваться гитом и гитхабом, нужно создать пару ключей SSH. Объяснение подробностей работы асимметричного шифрования выходит за рамки данного курса; практическая версия говорит, что для авторизации вместо того, чтобы каждый раз вводить пароль, гит использует ключи шифрования, публичный и приватный. Публичный вы можете показывать другим людям и заливать на гитхаб: он удостоверяет, что вы это вы. Приватный вы держите у себя и никому не показываете. Работает примерно как когда в старых шпионских фильмах два агента разрывают купюру, и узнают друг друга по предъявлению второй половины.

### Практика 2.1: создание ключей

Опустим также подробности о преимуществах и недостатках алгоритмов шифрования (RSA/elliptic curves), драму о вездесущих шпионах NSA, которые пытались ослабить то и другое. Мастерским произволом мы создадим пару ключей так:

    ssh-keygen -t ed25519

После выполнения этой команды в скрытой директории `~/.ssh` должно появиться два файла: `id_ed25519` (это ваш приватный ключ, никому его не показывайте и даже на экран выводить не стоит), и `id_ed25519.pub` (это публичный ключ, который нужно добавить на гитхаб, пригодится и в других местах)

Сделайте `cat ~/.ssh/id_ed25519.pub`, скопируйте то что показалось, залогиньтесь в гитхаб (вы же зарегистрировались там?), выберите Settings `— SSH` and `GPG` keys, `new SSH key`, и запастите текст ключа.

Теперь вы готовы быть Контрибьютором в Опенсорс и Автором Проектов! А если ещё не готовы, я сейчас подожду 10 минут.

(Для удовлетворения любопытства: ed25519 это алгоритм цифровой подписи (EdDSA), параметризованный эллиптической кривой Curve25519, которая так называется потому что у неё один из коэффициэнтов равен 2^255 - 19. Ненужные аутистические подробности: https://en.wikipedia.org/wiki/EdDSA#Ed25519). Поскольку у нас курс не "введение в криптографию", разбирать эллиптические кривые мы не будем. А жаль (зачёркнуто)).

### Системы контроля версий

Итак — как подтвердит любой человек, работающий с компьютером — часто бывает необходимо сохранять промежуточные результаты работы и показывать их другим людям (а то и делать так, чтобы они могли сделать свою часть и прислать отредактированную версию для продолжения работы). Все знают, к какому размножению директорий и имён файлов вроде Отчёт_2018_3_на_этот_раз_точно_финальный_версия2_исправлено.docx это приводит.

Программистов эти проблемы касаются ещё больше: им нужно не только коммуницировать с коллегами, но и искать в промежуточных ревизиях баги и точно выяснять, где они появились (для, допустим, дизайнов в фотошопе эти трудности не так выражены). А также над большим проектом могут работать десятки и сотни людей как муравьи, растаскивающие кусок сахара, и делать так чтобы результаты их труда были видны каждому. Для этого они придумали на свою голову системы контроля версий (ревизий), наиболее распространённой из каковых сегодня является Git.

### Практика 2.2: установка git

Собственно, прямо сейчас нужно взять ваши менеджеры зависимостей ОС (вы ведь не забыли как ими пользоваться?) и установить git (нужный пакет так и называется). Жду :)

### Git: основные понятия

Гит сохраняет содержимое рабочего каталога (содержимое файлов в тех директориях, которые на данный момент отслеживаются) на тот момент времени, когда вы его об этом попросите. Такой слепок состояния называется snapshot, а процедура его создания — commit.

*—Закоммитить - это оттуда?*
*—Да. Но это слово несёт много неоднозначностей. :) Программисты его применяют с тех времён другой системы контроля версий, SVN, когда оно значило "выложить последние внесённые изменения на общий сервер, с которого его могут забрать другие". Гит работает иначе, и его "коммиты" локальны и видны только вам. Залить изменения в общий для команды репозиторий (например, на гитхаб) называется push, и говорят "запушить" :)*

Можно создавать несколько ветвей развития кода: допустим, вы осуществили несколько коммитов (то есть отредактировали код, записали состояние с комментарием, отредактировали ещё и добавили пару файлов, опять записали состояние — потом решили попробовать какую-то безумную идею, создали ветку "черновик", сделали изменения в ней, несколько раз опять записали промежуточные состояния, потом всё получилось, вам не понравилось, и вы решили вернуться обратно к "чистовой" ветке — вот так тоже можно делать).

Можно сравнивать снапшоты (состояния директорий и файлов) между разными ветками и сливать их в одну ветку теми или иными способами. Часто это бывает, когда одну ветку пишет один человек, а другой — другой. Например, когда вы реализуете новую функциональность — вы можете скопировать любой публичный репозиторий (то есть дерево изменений исходного кода) к себе на гитхаб-аккаунт и потом в локальный гит-репозиторий, сделать новый код в отдельной ветке, залить результат обратно на гитхаб и создать формальный запрос к владельцу оригинального репозитория, чтобы он рассмотрел ваши гениальные изменения и интегрировал их в основную ветку кода. Эта процедура называется "пулл-реквест" (pull request); обычно сопровождается большой драмой в комментариях и убеждениями, что с этим новым кодом всё замечательно (со стороны автора), или что его писала курица сломанной лапой (со стороны владельца репозитория). Иногда удаётся найти компромисс, и код включается в основную ветку.

Так происходит коллективное программирование почти во всех публичных проектах и многих непубличных на работе.

### Git: первые команды

Теперь запишем те самые волшебные заклинания, о которых говорилось в xkcd (авось хватит на первое время):

`git init` — запускается в директории нового проекта, создаёт в любой директории с кодом локальный git-репозиторий. Пустой. Добавлять туда код, даже существующий, нужно другими командами.

`git add <имя_файла>` — сказать гиту, что теперь этот файл (или директорию со всеми поддиректориями) нужно добавлять в следующий snapshot. Все изменённые файлы надо добавлять таким образом вручную (или указать ключ в другой команде, git commit -a, который тогда вносит изменения автоматически).

`git commit -m "комментарий"` — собственно, создать снэпшот (коммит), сохранив состояние дерева файлов на данный момент. Параметр -m обязателен. Обычно коммит делается, когда закончен какой-то осмысленный кусок работы, который можно откомментировать. Хотя кого мы обманываем, делается он когда попало, а в качестве комментария пишется "работаю, отвалите".

`git push` — залить ваши коммиты во внешний репозиторий (например, на гитхаб). По умолчанию — только в текущей ветке; можно это сделать во всех ветках (`git push --all`). Гит может пожаловаться, что за это время кто-то уже что-то успел натворить с кодом, и push пройти не может, тогда нужно сделать (точнее, лучше бы это было сделать заранее, но что теперь):

`git pull` -- загрузить новые коммиты из другого репозитория (опять же, скорее всего гитхаба) к вам, опять-таки по умолчанию в текущей ветке. Ветка по умолчанию называется `"master"`, а сервер, с которым вы синхронизируетесь, называется `"origin"` — его конкретный адрес устанавливается обычно один раз при начале работы, гитхаб говорит как.

### Git: практика 2.3

Итак, теперь вам нужно:

* создать директорию с новым проектом, `ltc02`
* добавить туда файл `readme.txt`, с текстом, например, `"LearnToCode Project 2"`
* инициализировать там локальный гит-репозиторий
* добавить файл в проект
* сделать первый коммит, сохраняющий состояние проекта
* создать новый репозиторий на гитхабе 
* добавить данные гитхаба (так, как сказал вам гитхаб при создании нового репозитория — "добавить существующий проект")
* сделать `git push`.

Это, конечно, непросто, но делать нечего. Удачи!

## S02E03. Hello world на JS и С

### JavaScript

С языком Javascript мы уже знакомы, потому что писали на нём последнюю практику. В этот раз мы добавим к нему ещё язык C, на котором будем повторять разбираемые конструкции.

Так, давайте попробуем. На этом модуле мы будем учиться собственно программировать — то есть использовать наиболее распространённые конструкции языков программирования. Разных. Заодно будет немного больше упора на низкоуровневое программирование (и мы даже немного попишем на настоящем ассемблере и напишем на нём код, который компьютер сможет выполнить с самого начала, ещё не загрузив никакую операционную систему, прямо вот этим вот процессором). Когда ещё удастся?

### Практика 2.4 (Hello world на JS)

На данный момент, если вы прошли практику, у вас достаточно знаний, чтобы написать Hello, world на Javascript (программу, которая печатает на экран Hello, world — на Javascript это будет одна строчка). Создайте у себя в директории проекта поддиректорию js, там файл hello.js, напишите соответствующий код и запустите его (это тривиальная задача, но необходимая, потому что без хелловорлда никто не начинает программировать, извините. Традиция-с.)

### C

Теперь рассмотрим то же самое на C. В отличие от Javascript, нельзя просто так взять и написать одну строчку на C, которая бы делала что-то подобное. Нельзя потому что:

1) в голом C нет функции, которая выводила бы что-то на экран. Потому что программы на C могут компилироваться для самых разнообразных условий и устройств, в том числе таких, где нет экрана, а есть только допустим светодиод, которым можно помигать. К счастью, функция, которая таки печатает что-то на экран, входит в стандартную библиотеку, модуль stdio, и называется printf.

(Счастливцы, у которых работает man, могут даже почитать к ней олдскульную документацию прямо из терминала: man 3 printf).

2) в C выполнение программы обязательно начинается с функции main. Это для того, чтобы неповадно было заводить глобальные переменные, доступные для изменения кому попало — то есть в принципе тоже можно, но требует некоторых усилий (пожалуйста, не надо). Так или иначе, эту функцию необходимо написать.

Код функции в C выглядит, упрощая, примерно следующим образом:

    тип_возвращаемого_значения название_функции(тип_аргумента аргумент1, тип_аргумента аргумент2, ...) {
        выражение;
        выражение;
        ...
    }

*— Отступы важны?*
*— Отступы теоретически не важны. На практике нужно писать код так, как другие программисты в текущем проекте, иначе вам прилетит и всё равно заставят.*

Функция в C (и в Javascript) может принимать от нуля до много аргументов (в разных версиях много — от 31 до 127), а возвращает максимум одно значение (можно ни одного). Так повелось. Могло быть и по-другому; в некоторых языках программирования функция может и принимать, и возвращать только одно значение (например в Haskell), а бывает, что можно и принимать, и возвращать много (например, в PL/SQL).

Как правило, функция что-то «делает». Делать она может или чистые вычисления, которые возвращаются тому коду, который её использует, в виде результата — такие функции называются «чистыми» (pure). Или же она помимо этого может производить какие-то действия с окружающим миром, например, печатать строчки на экран, посылать пакеты в сеть, бибикать и всё портить. Такие действия называются «эффекты», а функция с эффектами, соответственно — не чистая.  Отделять чистые функции от нечистых не менее увлекательно, чем животных на ковчеге.

### Практика 2.5 (Hello world на C)

Учиться использовать функции мы будем на следующем занятии, а пока ваша задача — написать наконец hello world на C по шаблону, который я вам дал, зная следующее:

* строчка на экран выводится функцией printf (она принимает первым аргументом строчку — "строковый литерал" — в двойных кавычках; другие аргументы вам не нужны);
* таковая находится в модуле стандартной библиотеки stdio;
* чтобы включить модуль библиотеки, нужно в начале файла с исходным кодом написать #include "имя_модуля.h" (.h -- это расширение заголовочных файлов, о которых я тоже расскажу позднее);
* функция main возвращает значение типа int, и если ничего не возвращать явно — вернёт 0 (это значение используется операционной системой, чтобы узнать, удачно ли завершилось выполнение программы);
* в самом простом виде функция main может быть без аргументов;
* выражения, составляющие тело функции (в данном случае одно) заканчиваются точкой с запятой.

Создайте в проекте директорию "c" (без кавычек, само собой), и в ней файл hello.c, в котором напишите вот это всё. 

Скомпилируйте его командой `cc -o hello hello.c`, и запустите получившуюся программу командой `./hello`

Не забудьте добавить `hello.c` и `hello.js` в гит, сделать коммит, и запушить код на гитхаб! 

Скомпилированный файл программы (`./hello`) в гит добавлять не надо.

Постарайтесь сделать всё это (на этот раз) не заглядывая в интернет — сейчас информации в лекциях достаточно.

Но вообще это плохая идея — интернет для того и даден, чтобы в него заглядывать, а программистам особенно. Чёрт с вами, делайте что хотите, но чтобы к завтрему всё лежало на гитхабе. 🙂

NB Проверил (аж целых пять штук!) Всё должно работать, сейчас я только сделаю несколько общих замечаний.

Как вы, должно быть, заметили, у языков программирования помимо обязательного синтаксиса есть необязательная форма записи, которую принято называть **стилем** (**code style**). То есть, например, в C можно не делать отступы, или не ставить пробелы до/после операторов, или ставить лишние.

Но! Лучше этого не делать и всегда записывать код аккуратно. Компилятору всё равно, но другим программистам (а также вам самим через несколько месяцев) гораздо удобнее читать код, который написан в соответствии с каким-то стандартом стиля (их возможно несколько), чем как попало. Любой код (кроме машинного, да и у того есть текстовое представление) мы пишем не для компьютера, а для людей. Поэтому другие программисты всегда очень придираются к оформлению. Я тоже буду, чтобы было как по-настоящему.

Я сейчас порекомендую стили для C и Javascript. Если вам прямо поперёк горла эти рекомендации, то пишите как знаете, но только чтобы всегда все формы записи были одинаковы. :)

## S02E04. Функции

Так, во-первых, я обнаружил, что забыл написать, как записывается функция в Javascript. Несколькими способами, но сейчас нас интересует такой (наиболее часто встречающийся):

    function имя_функции(аргумент1, аргумент2, ...) {
        выражение;
        выражение;
        ...
    }

Давайте посмотрим, чем это отличается от C.

В Javascript функция всегда обозначается словом `function`, а в C достаточно просто имени и типа возвращаемых данных.

Но это не главное отличие — в Javascript мы не видим типов данных! Потому что их "нет", точнее, типизация динамическая — никто не проверяет, возвращаем мы строку, число или что-то ещё. Если мы пытаемся что-то сделать со значением, что оно не поддерживает (например, умножать строки) — программа на Javascript в этом месте завершит работу с ошибкой во время выполнения. Программа на C же даже не скомпилируется, потому что компилятор знает заранее, какого типа у функций и аргументов значение, и выдаст ошибку сразу при попытке компиляции (это называется **"статическая"** типизация).

Функции, которые вы пишете, можно _вызывать_ в других фрагментах кода (возможно, не один раз, меняя только параметры), и получать результат (и/или какое-то действие). 

Таким образом, функции помимо прочего служат для организации кода.

Правило (не всегда соблюдаемое, но лучше его иметь в виду): в одной функции должен быть код для какого-то одного действия (иногда это очень большое действие — но не относящихся друг к другу вещей лучше внутри одной функции не делать, вам же потом сложнее разобраться будет).

Вызывается функция одинаково и в C, и в Javascript:

    имя_функции(аргумент1, аргумент2, ...)

получившийся результат можно записать в переменную, можно вернуть на уровень выше с помощью `return` (тоже одинаково и там и там), а можно просто использовать прямо вызов функции в качестве аргумента другой функции

Например, в Javascript это так:

    let переменная = имя_функции(аргументы...) 

(вместо let может быть var или const, var сейчас лучше не использовать — он засоряет глобальное пространство видимости, а const удобен, если вы не собираетесь больше менять значение этой "переменной", то есть это уже не переменная, а константа)

а в C так:

тип_переменной переменная = имя_функции(аргументы...);

при этом тип переменной должен совпадать с типом возвращаемого значения функции, иначе компилятор вас отругает!

— Если речь идет не о выборе имен и внутренней структуре, порядке, ... — а только о пробелах и отступах — то почему это не забота редактора?
— Если в вашем редакторе есть функция автоматического форматирования кода — конечно, можно использовать её. Лишь бы на гитхабе всё было чётко. :)
Практика 2.6 (Функция, печатающая сумму аргументов)
Полученных знаний должно вам хватить, чтобы написать (на C и Javascript) функцию, которая принимает два аргумента (целочисленных на C — напомним, что это тип int), и возвращает их сумму. Эту функцию нужно вызвать, сохранить результат в переменную и напечатать получившееся.

В C ещё есть нюанс — функция printf принимает только аргументы строкового типа (char*), а всё остальное не принимает. Но она умеет работать с шаблонами форматирования (о которых будет отдельная лекция), а пока вот:

printf("some_variable is %d", some_variable) подставит значение переменной типа int на место %d, и выведет получившееся. Можно просто написать printf("%d", some_variable).

Создайте в js и c файлы sum.js и sum.c, напишите код с такой функцией, сделайте коммит и пуш на гитхаб.

S02E05. Функции. Продолжение: условные и логические операции 

Как я говорил в самой первой лекции, программы описывают исполнение команд в соответствии с условиями. Пока что мы записывали команды (выражения в C и Javascript) просто одна за одной, и ещё организовывали их в функции.

И в C, и Javascript существует конструкция if, который направляет выполнение по одному из нескольких путей в зависимости от результата вычисления какого-либо выражения (есть ещё switch/case, но пока мы о нём не будем) — а также его сокращённая форма, с вопросом и двоеточием.

Выглядит она так в полной форме (одинаково и в том, и в другом языке), количество блоков else if может быть неограниченным (в том числе и 0), но else максимум один.

if (какое_то условие) {
   выражение;
   выражение;
   ...
} else if (другое условие) {
   выражение;
   выражение;
   ...
} else {
   выражение;
   выражение;
   ...
}

Работает тоже очень просто — если результат вычисления выражения в скобках if истинный (о том, какой результат считается истинным, мы поговорим позже), выполняется блок кода сразу за if. Иначе проверяется условие в else if, если оно истинно — выполняется этот блок кода, если нет — переходится к следующему else if, и т.д. Если else if закончились и ни одно условие не сработало, то выполняется блок кода, который находится после else (если он есть).

– происходят ли какие-то проверки насчет выражений в else if'ах, если уже первое условие выполнится?
– Нет. Они даже не будут вычисляться.
– но хотя бы синтаксически они должны быть корректные?
– Конечно, иначе код не скомпилируется.

Теперь немного о грустном. В приличных языках программирования есть так называемые логические типы данных, которые могут принимать только два значения, истинное или ложное. Выражения, которые могут стоять в условии if, могут вычисляться и принимать только эти значения. Например, 2 * 2 == 4 — это истина, а 5 < 3 это ложь. 

(Двойной знак равенства — это операция _сравнения_, в отличие от одинарного знака равенства, которое является _присваиванием_. Если знак равенства отвечает на вопрос, используйте двойной, а если вы хотите присвоить значение чему-нибудь, то одинарный. За этим нужно следить — перепутать легко, а последствия могут быть страшны.)

– Если первое верное выражение выполнилось, что с ним дальше происходит?
– В смысле, первое условие истинно, и выполнился блок кода который сразу после if? Остальные блоки кода, если они есть, пропускаются, и дальнейшее выполнение кода идёт после окончания всей конструкции if (последней закрывающей фигурной скобки, к ней относящейся).

Но: в C нет логических переменных. Так получилось. Вместо этого в условиях используются целые числа, при этом 0 считается ложью, а всё остальное (включая отрицательные числа) — истиной. Очень кстати неудобно.

Убедиться в этом несложно: можно написать в C такое выражение:

int result = 6 > 5

(то есть: присвоить переменной result результат вычисления выражения 6 > 5). Его можно распечатать как любое другое число. Получится 1 («истина», то есть). Можете попробовать.

В Javascript же логические значения вроде есть... например

let result = 6 > 5

присвоит переменной result значение true (истина; а false это ложь, это зарезервированные ключевые слова). Казалось бы, всё хорошо. Но! Неведомо зачем Javascript также понимает в условии if и числа, интерпретируя их так же как C. А ещё там есть undefined. Что создаёт ВЕЛИКОЕ МНОЖЕСТВО проблем, которых не было если бы авторы языка были бы тогда немного более внимательны. (А сейчас что-то менять уже поздно, иначе перестанет работать старый код).

Проверки условий можно комбинировать с помощью так называемых булевых (логических) операций. Они тоже одинаково записываются в двух языках, и выглядят так:

a && b
— это логическое И (AND), выражение верно, только если оба условия a и b верны одновременно;

a || b
— это логическое ИЛИ (OR), выражение верно, если хотя бы одно из условий a или b верно;

!a
— это логическое отрицание (NOT), выражение верно, если условие a неверно.

Операторы && и || имеют особенность: в случае с (a && b) если вычисленное значение a ложно, то b уже не вычисляется (потому что в любом случае результат известен — ложь). Обратно, когда мы вычисляем (c || d), если c истинно, то d уже не вычисляется, так как уже понятно, что результат — истина. Это имеет значение, когда в результате вычисления a или b происходит что-то ещё (побочные эффекты).

Логические операторы, то есть &&, || и !, можно комбинировать в длинные выражения. У операторов при этом есть приоритет, так же как в арифметических выражениях сначала мы считаем умножение, а потом сложение (2 + 2 * 2 будет 6, а не 8).

Соответственно, у отрицания самый высший приоритет, у логического И — средний, и самый низкий у логического ИЛИ.

– для !a какие-то скобки вокруг a нужны?
– нет (нужны только если a это сложное выражение)

Как и в случае с арифметикой, приоритет операций можно переобозначить скобками.

– ну это вопрос приоритетов — у ! он самый высокий?
– да

Операции сравнения, которыми можно сравнивать числа: >, >=, <, <=, ==, != (больше, больше или равно, меньше, меньше или равно, строго равно, строго не равно).

Как проверить, что значение переменной лежит в интервале? Например, 0 < x < 10 (так не работает).

Нужно одновременно проверить два условия:

x > 0 && x < 10

На этом месте полагается давать кучу упражнений на раскрытие скобок, таблицы истинности, правила де Моргана, нормализацию и прочую скучную и нудную ерунду. Но у меня не было времени их написать.

Поэтому вместо этого мы будем рисовать остальную сову (а упражнения будут завтра).
Практика 2.7 (Расчет BMI)

Написать программу на C (на джаваскрипте примерно то же самое, только читать значения из пользовательского ввода сложнее — поэтому на нём не надо), которая:

– запрашивает у пользователя его рост и вес с помощью функции scanf (как ей пользоваться, посмотрите в гугле);

– вычисляет его/её индекс массы тела (формулу посмотрите в гугле, вычисление сделайте отдельной функцией);

– если индекс массы тела ниже нижней границы нормы, выведите сообщение, что он низкий, если выше верхней границы нормы — выведите сообщение, что он высокий, если в пределах нормы — выведите сообщение, что в пределах нормы.

Значения границ «нормы» возьмите для своего пола в гугле или напишите какие вам интересны. Задание со звёздочкой — спросить у пользователя также пол, и использовать значения интервала «нормы» в соответствии с ним.

Редакция напоминает, что BMI не является разумной метрикой «красоты» или «здоровья», упражнение не несёт никакого нормативного смысла кроме обучающего, если вас триггерит использование BMI — можно придумать что-нибудь ещё. 🙂

Обратите внимание: в функции, которая вычисляет значение индекса массы тела, и в переменной, которой присваивается результат, должен быть тип float.

Результат закоммитить в гитхаб и показать мне 🙂

Я рекомендую сначала сделать для какого-то одного пола 🙂 Программы пишутся от простого к сложному.


– При вычислении один тип превратится в другой?
– И аргументы тоже. Про конверсию типов я тоже забыл рассказать, конечно. float это тип для действительных чисел (с плавающей точкой). То есть дробных. Читается/печатается в scanf и printf он шаблоном %f (а не %d).

Про ограничения точности, проблемы с арифметикой плавающей точки и прочих безднах тоже придётся рассказать в следующий раз.

Примечание из чата:
> let result = (!1) == 2 undefined > result false
В связи с этим есть трюк: если вы получаете какое-то значение откуда-то, и дальше планируете использовать его как логическое, используйте его не как есть, а как !!a — это будет простое и понятное булевское значение, а не что угодно.
S02E06. Рекурсия

Итак, на данный момент мы все умеем писать функции, вызывать функции, и выделять в функции логически обособленные куски кода. Некоторые также догадываются, что чистые функции предпочтительнее нечистых, и если можно отделять вычисления от эффектов, то лучше это делать (например, в прошлом задании вычислять BMI лучше отдельной функцией, а печатать его в main, или создать специальную функцию для печати).

Внутри одной функции можно вызвать другую, а внутри другой — третью, это тоже понятно. В конце концов, код и состоит из мешанины подобных вызовов. Вопрос, который на этом этапе должен всех интересовать — это "может ли функция вызвать саму себя?" Ну конечно может! Это явление и называется "рекурсия".

На первый взгляд кажется, что если функция вызывает сама себя, то это будет происходить до бесконечности. Так может быть, и даже у такого простейшего варианта рекурсии есть польза.
Практика 2.8. У попа была собака
Напишите программу, которая с помощью рекурсии, то есть вызова функцией самой себя, выводит на экран стихотворение "у попа была собака" на всю свою бесконечную длину (когда надоест, прерывать исполнение программы можно по Ctrl-C). То есть примерно так:

у попа была собака, он её любил
она съела кусок мяса, он её убил
в землю закопал
и надпись написал, что у попа была собака, он её любил
она съела кусок мяса, он её убил
в землю закопал
и надпись написал, что у попа была собака, он её любил
...

(Обратите внимание, какие из строк должны заканчиваться переводом строки, то есть символами \n. Разбивать на чистые и нечистые функции здесь не надо, функция должна просто печатать текст.)

Бесконечно исполняемые функции имеют ограниченное применение, поэтому обычно в рекурсивных функциях Яве есть условие ограниченияе. Например, если аргумент равен нулю — выйти из функции, в противном случае сделать что-то и вызвать саму себя с аргументом, уменьшенным на единицу. Таким образом можно писать интересные алгоритмы. 

Практика 2.9. Пиво
Написать программу, печатающую стихотворение "99 bottles of beer on the wall" — как оно выглядит можно посмотреть здесь: https://en.wikipedia.org/wiki/99_Bottles_of_Beer (на этот раз программа должна после вывода стихотворения завершить работу).

А именно:

99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around, 98 bottles of beer on the wall...
98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around, 97 bottles of beer on the wall...
97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around, 96 bottles of beer on the wall...
...
No more bottles of beer on the wall, no more bottles of beer.
We've taken them down and passed them around; now we're drunk and passed out!
Wikipedia 99 Bottles of Beer - Wikipedia

Задания можно выполнять на С или на Javascript, как вам больше нравится (или одно на одном, другое на другом).

– Язык не накладывает ограничений на глубину рекурсии?
– Стек может кончиться, но есть возможность писать код так, чтобы этого не произошло (tail call optimization). Об этом расскажу после того как все сделают эти задания.
S02E07. Рекурсия. Продолжение: способ мыслить рекурсивно
Как мыслить рекурсивно: патентованный метод, тайненькое знаньице! Чему учат в университете на факультетах computer science, но почему-то никто не пишет в книжках.

Итак — для очень многих часто встречающихся задач в программировании можно придумать изящный рекурсивный алгоритм. Делается это так (точно так же работает математическая индукция):

1) возьмите примитивный, вырожденный вариант проблемы. Если нужно сделать что-то со строкой — как будет выглядеть эта операция для пустой строки? А для строки для одного символа? Из двух?

2) придумайте, как свести задачу для n+1 элементов к задаче из n элементов, и выразите первое через второе.

3) Напишите рекурсивную функцию, которая делает что-то для n элементов (что вы выяснили в пункте 2) и вызывает саму себя для n-1 элементов (в конце концов она добирается до вырожденного варианта из пункта 1, который вы определили заранее).

Например, любимая задача на интервью: нужно инвертировать строку, то есть из abcde сделать edcba. Записываем:

Для пустой строки решение — пустая строка
Для строки из одного символа решение — эта же строка
Для строки из двух символов решение — поменять символы местами
Для строки из n символов решение — отсечь первый символ, инвертировать остаток строки вызовом функции для n-1 символов, приставить к результату отсечённый символ последним. То есть: 

reverse (“abc”) = reverse(“bc”) + “a” = “cb” + “a” = “cba”

Методом пристального всматривания можно заметить, что промежуточные пункты для одного и двух символов лишние: 

Для одного символа идея для n символов тоже работает
reverse("a") = reverse("") + "a" = "a"

Равно и для двух: 

reverse("ab") = reverse("b") + "a" = "ba"

Следовательно, в функции достаточно записать варианты для нуля и n символов. 
Практика 2.10: инвертирование строки

Так и сделаем! (На джаваскрипте, потому что C будет нас отвлекать ненужными деталями). Для этого нужно знать (или посмотреть в гугле, что я советую сделать в любом случае), что: 

"Взять символ номер n из строки" в джаваскрипте делается так же, как доступ к элементу любого массива: some_string[n], где нумерация начинается с нуля. Первый символ будет some_string[0];

"Взять остаток строки кроме первых n символов" - это string.substr(n), на этот раз _количество_ символов начинается с единицы;

"Остаток строки без первого символа" это some_string.substr(1);

"Узнать длину строки" — some_string.length

Остаётся дословно записать код:

function reverse(string) {
    if (string.length == 0) {
        return string
    } else {
        return reverse(string.substr(1)) + string[0]
    }
}

Проверьте, должно работать! (Это не очень оптимальный вариант, но разбором почему это так, мы займёмся в следующий раз — его легко переделать в оптимальный. Для наших целей его вполне достаточно). На всякий случай напоминаю, что проверить можно так:

console.log(reverse("abcdefghi"))


Практика 2.11: проверка на палиндромность

Напишите таким же способом функцию, которая проверяет, является ли её аргумент (строка) палиндромом, то есть читается так же слева направо, как и справа налево (если является, возвращает true, если не является, false).

То есть, например, "abcdcba" — палиндром, "aaaaa" — тоже, "abccba" — тоже, а "abcabc" — нет.

ВНИМАНИЕ! Есть большое искушение свести задачу к предыдущей и тупо сравнить строку с её инверсией. Такое решение засчитываться не будет — постройте функцию с нуля, воспользовавшись приведённой аргументацией.
Практика 2.12: регистронезависимая проверка на палиндромность 

Напишите функцию, которая проверяет строки на палиндромность так, как это принято на самом деле — игнорируя регистр, пробелы и знаки препинания. Например, is_palindrome("Madam, I'm Adam") должно возвращать true. Найдите в гугле, как сравнивать два символа, игнорируя регистр; как пропускать пробелы и знаки препинания, вы должны догадаться сами.

Задание, если вы раньше такого не делали, сложное — поэтому на его выполнение (и на то чтобы догнать курс) вам даётся два дня, завтра ничего не будет. И не стесняйтесь спрашивать, если не получается!
S02E08. Типы и структуры данных
Как мы уже говорили где-то на предыдущих лекциях, все данные в памяти компьютера представлены последовательностями байтов. В принципе, и в таком виде с ними можно работать, и иногда приходится. Но в большинстве языков программирования информация собирается из типов данных (value types), организованных в структуры данных (data structures) — а уже потом, на этапе компиляции или интерпретации, они отображаются в последовательности байтов в памяти (к которым часто даже нет прямого доступа).

Элементарные типы данных называются "примитивы". В разных языках программирования есть разные представления о том, что считать примитивом. Например, в C их очень много (и каждый может нести несколько названий, что запутывает), но вообще примитивные типы C - это либо разного рода числа, либо указатели. Примитивного типа "строка" в C нет, строка, как мы помним, это последовательность ASCII (или Unicode)-кодов, заканчивающаяся байтом 00. Нет и логических типов. Только числа (целые и дробные, точнее, с плавающей точкой), и адреса в памяти. Благодаря такому минимализму, компиляторы C существуют для чего угодно, хоть для часов и холодильников.

Про числа вы знаете (более подробно мы о них поговорим позднее), а указатель — это «адрес в памяти», ссылка на какое-то другое значение (сопровождаемая в коде — но не в памяти — информацией о том, что это такое может быть)

В Javascript типизация слабая — одно и то же значение вроде "1.2" в разных контекстах может быть интерпретировано и как строка, и как число (что создаёт немало проблем). Но всё-таки примитивные типы есть и там, хотя они и не подразделяются на бесчисленные подкатегории как в C (где одних числовых типов больше десятка). Зато в Javascript — не одни числа, а вот что:

логический тип (Boolean) — содержит только два значения, true и false. Операции сравнения, например, выдают результатом именно его.

неопределённый тип (Undefined) — если переменную просто определить, но не задать сразу её значение, оно будет именно таковым. Существует ровно одно значение типа Undefined — это undefined. :) Его любой программист на джаваскрипте видит часто.

числовой тип (Number). В отличие от C, числа в Javascript это "просто числа", а именно все числа — это 64-битные дробные числа с плавающей точкой. Про то, как устроено представление таких чисел, мы расскажем позднее, а пока упомянем, что это числа в двоичном представлении, вычисления с которыми создают небольшие погрешности в десятичном представлении. Поэтому нужно быть очень осторожными, сравнивая их.

Например, запустите REPL node.js и проверьте там результат выражения:

(0.2 * 0.2) == 0.04

ну и просто

0.2 * 0.2

Такие дела.

Строковый тип  (String). «Просто строки», последовательности «текстовых символов» неопределённой длины. Худо-бедно в джаваскрипте поддерживается юникод, с разной степенью смеха. Можно, например, попробовать операции смены регистра string.toUpperCase / string.toLowerCase для строки с вашими любимыми эмодзи.

Ещё в джаваскрипте есть примитивные типы Null («определённо пустое значение», в отличие от неопределённого undefined) и Symbol (уникальная строка) — последний новый и применяется редко. Больше примитивных типов в этом языке нет, все остальные типы — составные.

– почему ((0.2 * 0.2) == 0.04) считает как false?
– потому что компьютер считает дробные числа двоичной, а не десятичной арифметикой. В ней хорошо представляются двоичные дроби со знаменателем, кратным степени двойки (например, 1/4 или 1/512); привычные нам десятичные дроби можно представить лишь приближённо.

Это очень плохо; хотя сейчас можно было бы уже исправить ситуацию и сделать нормальные десятичные дроби примитивом, всем лень. Поэтому пока нужно запомнить, что сравнивать нецелые числа напрямую (кроме редких исключений, когда вы точно знаете что делаете — а пока вы не знаете) — нельзя. :((

Функции в джаваскрипте — тоже тип данных, который можно считать примитивным. Функции можно не только вызывать, но и присваивать переменным и передавать аргументами (а также функция может возвращать другую функцию), что бывает очень полезно. Сейчас дам ссылку на интересную статью Спольски про это:

https://www.joelonsoftware.com/2006/08/01/can-your-programming-language-do-this/
Can Your Programming Language Do This?

(рекомендую почитать — как часть лекционного материала)

В C есть тип «указатель на функцию», предназначенный для того же самого.

– а он по сути тоже "адрес в памяти", начиная с которого идет какой-то код, или это абстракция?
– да, по большому счёту так.

Тут нужно сделать интерлюдию — сказать, что языки программирования разделяются по уровню типизации. Она бывает слабая или сильная, а также статическая или динамическая.

Например, у C статическая и слабая типизация, а у Javascript — динамическая и слабая.

Сильная типизация означает, что значение одного типа не может быть проинтерпретировано как значение другого типа без явных преобразований — а слабая, соответственно, что может.

Как в C, так и в Javascript, такая операция возможна без особых ухищрений. Если же результат такой операции не очень имеет смысл, программа выдаст ошибку в процессе выполнения (а компилятор вам про неё не сообщит, поэтому искать такие ошибки бывает очень увлекательно).

Например, попробуйте умножить в Javascript строку на какое-нибудь число. Эта операция возможна, и компилятор не пожалуется! Результатом будет NaN (not a number — специальное псевдо-число, зарезервированное за результатами некоторых арифметических операций, вроде квадратного корня из минус единицы за неимением комплексных чисел). В общем, бардак.

В языках с сильной типизацией такие вещи невозможны, поэтому многие ошибки удаётся отловить раньше. Насколько раньше — это решается в дилемме "статическая/динамическая".

В C типизация статическая, то есть при объявлении переменных, декларировании аргументов функции и того, что она возвращает, нужно обязательно сразу указывать их тип (вроде int i = 42 или char* s = "Hello!").

Это помогает: после этого переменной типа int уже нельзя присвоить строку, и наоборот (а в Javascript пожалуйста).

В Javascript с динамической типизацией тип переменных нигде в коде не указывается, и любой переменной может быть присвоено любое значение, и любая функция тоже может возвращать всё что угодно. Допустить ошибки в таком языке проще, а отлаживать код соответственно сложнее.

Наиболее известный язык с сильной и статической типизацией — Java. Он многословный, но зато позволяет избежать целого класса ошибок, распространённых в языках без статической/сильной типизации. Но Java это такой "необходимый минимум", есть сильно и статически типизированные языки с гораздо более широкими возможностями (например, Rust, Scala и Haskell). Про них ходит шутка "если программа скомпилировалась, она работает" — и часто это действительно так, хотя добиться этой компиляции бывает непросто.

Языки с сильной, но динамической типизацией редки, но существуют (например, Smalltalk).

Одними примитивными типами программировать неудобно, поэтому существуют составные типы, они же структуры данных [последний термин более низкоуровневый, обычно подразумевает их внутреннее устройство].

Почти во всех языках программирования существуют типы-последовательности (отличающиеся внутренним устройством, это могут быть связанные списки, массивы и более экзотические конструкции, например множества) и типы-словари (деревья, хэш-таблицы, и другие). Ещё бывают tuples или структуры — жёстко заданные совокупности примитивных типов (в отличие от словарей, в которых содержимое можно задавать динамически в процессе выполнения программы).

Например, int[] — это тип-последовательность "массив целых чисел" в C. Поскольку память в C выделяется вручную, нужно сразу указывать его размер при инициализации, что тоже приводит к множеству забавных ошибок. В Javascript есть встроенный тип "массив чего угодно", например, [] это пустой массив, а [1,2,3,4,5] это массив с числами.

С последовательностями, массивами в том числе, возможны какие-то стандартные операции. Можно узнать его длину (в C и это нетривиально, но несложно). Существует индексирование, то есть выбор элемента по его порядковому номеру (начиная с нуля). Бывает возможным разбить последовательность на несколько по какому-то критерию, или скопировать одну в другую.

Массив отличается от связанного списка тем, что в массиве значения всегда находятся друг рядом с другом в памяти, а в связанном списке — не обязательно, там просто каждый элемент указывает на следующий (бывает двусвязный список, там и на предыдущий). Это влияет на скорость операций: например, в большой массив сложно вставить элемент в середину, а в большой связанный список это сделать тривиально. Зато в массивах можно очень быстро получить элемент по его индексу, а в связанном списке для этого придётся проходить элементы один за другим, пока не достигнешь нужного.
(в стандартной библиотеке как Javascript, так и C, связанных списков нет, только массивы. При этом в C они ещё и не динамические, то есть добавлять/удалять элементы нельзя — можно только создать массив побольше-поменьше и скопировать туда элементы из предыдущего. Но всё это и многое другое есть в сторонних библиотеках).
Я тут решил попробовать давать меньше материала, но каждый день, так что про словари (и объекты в JS) будет уже завтра. А на сегодня небольшое задание:
посмотреть и попробовать, как в C и Javascript (начните с Javascript) можно:

- создать массив чисел
- создать массив строк
- узнать длину массива
- получить элемент по индексу
- получить последний элемент

и только в javascript:

- добавить элемент в начало
- добавить элемент в конец
- удалить элемент по индексу
- объединить два массива в один
- применить функцию ко всем элементам массива и получить новый той же длины


Да, про примитивные типы в C я забыл рассказать, так как там очень много числовых типов разных размеров, но их можно посмотреть например тут: https://en.wikipedia.org/wiki/C_data_types


