## Указатели

Итак, в прошлый раз мы пописали немного на ассемблере и убедились, что это довольно утомительно. BIOS выводит информацию посимвольно, значения из памяти можно переносить в регистры максимум по несколько байт за раз, все алгоритмы нужно придумывать заново (даже число просто так не распечатаешь, нужно вручную придумывать алгоритм, который переводит числовое значение в последовательность ASCII-кодов, которые можно напечатать через BIOS, и из человеколюбия я не буду заставлять вас это делать). Хотя в принципе если кто склонен к некоторому мазохизму, то есть страдает жаждой познания, то продолжать ассемблерные опыты можно (и очень рекомендуется!) здесь: http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf

Вернёмся к C. Хотя многие справедливо называют C "таким продвинутым макроассемблером", намекая на его низкоуровневость — всё же он абстрагирует работу с памятью, вызовами функций и типами данных, потому что делать это совсем уж вручную ужасно надоедает. Например, аргументы функций и переменные внутри тела функции автоматически распихиваются компилятором по регистрам и стеку (такая выделенная область памяти, в которую можно запихивать значения из регистров один за другим, а потом доставать в обратном порядке по одному за раз; полезна, так как регистров мало и для всего не хватает, но работать с ним вручную на ассемблере опять же крайне утомительно).

Помимо регистров и констант, на ассемблере мы можем работать с памятью, указывая в качестве аргументов командам адреса памяти (смещения, куда можно записать / откуда прочитать значения). В C такой фокус тоже бывает необходим; чистые адреса в нём заменяются на *указатели.

Что такое указатель в C? Указатель это адрес в памяти, снабжённый сведениями о размере того, что там может находиться (просто одного значения, или одного элемента из нескольких). Само абсолютное значение адреса в памяти нам неинтересно, и, как правило, оно не имеет отношения к действительности (разве что их можно сравнить, чтобы узнать, не указывают ли два указателя на одно и то же место в памяти).

Указатель в C обозначается звёздочкой между типом и названием аргумента или переменной. Например, ´int* some_var´ — это переменная, содержащая указатель на значение типа int. Как вы уже знаете, любой массив в C — это указатель на первое из его значений, а строка — указатель на первый символ.

Разберём пример. Напишем в C (внутри функции main, с инклюдами, как положено) что-то в этом роде:

    int x = 1;
    int y = x;
    x = 5;
    printf("%d", y);

что выведется результатом?

(ответ: 1. Мы поменяли значение переменной ´x´, но это не распространилось на значение переменной ´y´, которая когда-то была равна ´x´, но сейчас уже нет, так как значение ´x´ поменялось, а ´y´ нет.)

Как сделать так, чтобы если мы сказали, что ´y´ равно ´x´, то так всегда и было? С помощью указателей.

(Напомним: объявляется указатель звёздочкой после типа переменной. Получить указатель на переменную можно поставив перед её именем символ &. Наоборот, имея указатель, можно его разыменовать, то есть получить лежащее по этому адресу значение, опять поставив перед ним звёздочку).

Вот так:

    int x = 1;
    int* y = &x;
    x = 5;
    printf("%d", *y);

(´y´ теперь — указатель на значение типа int, сейчас указывает на значение переменной ´x´. Когда значение ´x´ поменялось, указатель стал указывать на новое значение, его мы и напечатали. Будет напечатано значение 5).

Функции могут принимать указатели аргументами (такова, например, уже известная нам функция ´scanf´, которая принимает указатель на переменную, куда нужно записать прочитанное из пользовательского ввода значение).

Интересно, что функция может изменить значение, находящееся по указателю (если только аргумент-указатель не объявлен с модификатором ´const´, например ´const int* argument´ — тогда не может).

