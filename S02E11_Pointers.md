## Указатели

Итак, в прошлый раз мы пописали немного на ассемблере и убедились, что это довольно утомительно. BIOS выводит информацию посимвольно, значения из памяти можно переносить в регистры максимум по несколько байт за раз, все алгоритмы нужно придумывать заново (даже число просто так не распечатаешь, нужно вручную придумывать алгоритм, который переводит числовое значение в последовательность ASCII-кодов, которые можно напечатать через BIOS, и из человеколюбия я не буду заставлять вас это делать). Хотя в принципе если кто склонен к некоторому мазохизму, то есть страдает жаждой познания, то продолжать ассемблерные опыты можно (и очень рекомендуется!) здесь: [http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf](http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf)

Вернёмся к C. Хотя многие справедливо называют C "таким продвинутым макроассемблером", намекая на его низкоуровневость — всё же он абстрагирует работу с памятью, вызовами функций и типами данных, потому что делать это совсем уж вручную ужасно надоедает. Например, аргументы функций и переменные внутри тела функции автоматически распихиваются компилятором по регистрам и стеку (такая выделенная область памяти, в которую можно запихивать значения из регистров один за другим, а потом доставать в обратном порядке по одному за раз; полезна, так как регистров мало и для всего не хватает, но работать с ним вручную на ассемблере опять же крайне утомительно).

Помимо регистров и констант, на ассемблере мы можем работать с памятью, указывая в качестве аргументов командам адреса памяти (смещения, куда можно записать / откуда прочитать значения). В C такой фокус тоже бывает необходим; чистые адреса в нём заменяются на *указатели.

Что такое указатель в C? Указатель это адрес в памяти, снабжённый сведениями о размере того, что там может находиться (просто одного значения, или одного элемента из нескольких). Само абсолютное значение адреса в памяти нам неинтересно, и, как правило, оно не имеет отношения к действительности (разве что их можно сравнить, чтобы узнать, не указывают ли два указателя на одно и то же место в памяти).

Указатель в C обозначается звёздочкой между типом и названием аргумента или переменной. Например, `int* some_var` — это переменная, содержащая указатель на значение типа `int`. Как вы уже знаете, любой массив в C — это указатель на первое из его значений, а строка — указатель на первый символ.

Разберём пример. Напишем в C (внутри функции main, с инклюдами, как положено) что-то в этом роде:

    int x = 1;
    int y = x;
    x = 5;
    printf("%d", y);

что выведется результатом?

(ответ: 1. Мы поменяли значение переменной `x`, но это не распространилось на значение переменной `y`, которая когда-то была равна `x`, но сейчас уже нет, так как значение `x` поменялось, а `y` нет.)

Как сделать так, чтобы если мы сказали, что `y` равно `x`, то так всегда и было? С помощью указателей.

(Напомним: объявляется указатель звёздочкой после типа переменной. Получить указатель на переменную можно поставив перед её именем символ `&`. Наоборот, имея указатель, можно его разыменовать, то есть получить лежащее по этому адресу значение, опять поставив перед ним звёздочку).

Вот так:

    int x = 1;
    int* y = &x;
    x = 5;
    printf("%d", *y);

(`y` теперь — указатель на значение типа `int`, сейчас указывает на значение переменной `x`. Когда значение `x` поменялось, указатель стал указывать на новое значение, его мы и напечатали. Будет напечатано значение 5).

Функции могут принимать указатели аргументами (такова, например, уже известная нам функция `scanf`, которая принимает указатель на переменную, куда нужно записать прочитанное из пользовательского ввода значение).

Интересно, что функция может изменить значение, находящееся по указателю (если только аргумент-указатель не объявлен с модификатором `const`, например `const int* argument` — тогда не может).

### ЗАДАНИЕ. Вывод ответа на главный вопрос вселенной (с помощью указателей). 

Напишите на C функцию возвращающую `void` (то есть ничего), принимающую аргументом указатель на значение типа `int` и умножающую его на два. В `main` объявите переменную `int` со значением `42`, вызовите вашу функцию с указателем на эту переменную, и распечатайте её значение после модификации.

### Продолжение. Указатели на функции

Указатели могут быть не только на переменные, но и на массивы (это мы знаем), на произвольные выделенные области памяти (об этом мы поговорим позже), на другие указатели (например, `char**`), и на функции. Последняя штука полезна, так как даёт возможность функциям принимать другие функции как аргументы и возвращать тоже функции, если надо.

Такова например присутствующая в `stdlib.h` функция `qsort`, которая может отсортировать массив чего угодно (хоть чисел, хоть структур, хоть строк и т.п). `qsort` принимает такие аргументы:

* указатель на сам массив;
* длину массива;
* размер элемента массива (для этого в C есть удобная конструкция `sizeof(тип)`, например `sizeof(int)` для целых чисел);
* указатель на функцию сравнения элементов массива — принимает два указателя на `void` (то есть любого типа, которые можно потом проинтерпретировать как нужный) и возвращает `-1`, `0` или `1` в зависимости от того, в каком порядке эти два значения расположены. Такая функция называется *"компаратор"*.

Например, чтобы отсортировать значения массива в прямом порядке, компаратор для значений `a`, `b` должен выдавать:

    если a < b: 1 (правильный порядок a и b)

    если a > b: -1 (неправильный порядок a и b)

    если a == b: 0 (всё равно в каком порядке равные a и b)

Компаратор позволяет сортировать не только по возрастанию-убыванию, но и в любом другом порядке. Он объясняет сортировочной функции, что именно мы имеем в виду под «порядком».

### ЗАДАНИЕ. Компаратор для сортировки в обратном порядке

Дан массив из 10 чисел, например:

    int array[10] = {3, 5, 1, 7, 2, 7, 6, 0, 8, 4}

Напишите функцию-компаратор для `qsort` для сортировки в _обратном_ порядке.

Поскольку функция принимает указатели на `void`, а нам нужны на `int`, их нужно проинтерпретировать как таковые (это называется *to cast*, по-русски говорят *«привести к типу такому-то»*, хотя кого мы обманываем, все так и говорят *«прокастовать»*): 

    int reverse_sorter(const void *first_arg, const void *second_arg) {
        int* first = (int*) first_arg;
        int* second = (int*) second_arg;

        /* здесь ваш код сравнения, возвращающий -1, 0 или 1 */

    }

(Обратите внимание, что компаратор принимает указатели, помеченные `const` — это сделано для того, чтобы он не смог поменять значения, находящиеся там).

Написав компаратор, вызовите с ним `qsort`, чтобы отсортировать массив в обратном порядке. Распечатайте результат.

Постарайтесь не искать в гугле «как пользоваться qsort», а попытаться разобраться самостоятельно.

### Дополнительное задание: как работает Quicksort

Прочитайте в википедии, как работает Quicksort (алгоритм сортировки, реализуемый функцией `qsort`). Довольно странный и интуитивно малопонятный алгоритм, но работает хорошо! Заодно прочитайте про `merge sort`, `insertion sort` и др. — чем они отличаются и как работают. Найдите все доступные алгоритмы сортировки в стандартной библиотеке C.

### Задание с Большой Звёздочкой

Попробуйте написать merge sort на C самостоятельно, с такими же принимаемыми аргументами. Это вот будет непросто, зато точно разберётесь! Кроме того, это стандартный вопрос на интервью в приличные места.
