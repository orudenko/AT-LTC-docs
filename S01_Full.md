## S01E01. 5 миров программирования 

Окей, сегодня мы говорим, какое бывает программирование (издали похожее на мух). Классификаций много, объединяющий принцип один — **программирование это написание плана для выполнения команд в зависимости от условий**. Что из этого следует? 

1. Должно быть что-то, что понимает какие-то команды и умеет их выполнять. Это называется «среда выполнения» (runtime environment). Это может быть что угодно: физическое железо, операционная система, браузер, другая программа etc. Командовать можно процессором (сложить числа в этой и той ячейке, результат поместить туда-то), браузером клиента (при нажатии на эту кнопку показать такую-то картинку), операционкой (открыть файл такой-то и начать читать содержимое) и чем угодно что это позволяет. 

2. Команды для удобства человека как-то записываются. Языки программирования — это семантические средства, помогающие описывать последовательности команд и условия их выполнения множеством разных способов. Кто во что горазд и кому как больше нравится. Если мы командуем непосредственно компьютерным железом, это называется «системное» программирование. Если железо мельче и/или специализированнее компьютерного (мелкая электроника, промышленное оборудование) — это называется embedded программирование (то и другое — «низкоуровневое» программирование). Попытки командовать всем остальным — это «прикладное» программирование (оно же «высокого уровня»). Термины довольно дурацкие, но так получилось.

3. «План» означает, что программа записывается один раз (а редактируется и отлаживается с матами многократно, но не будем о грустном), а запускается когда угодно потом (возможно, много раз, или работает непрерывно). То есть написание программы и её выполнение обычно отделены по времени и среде, за очень редкими исключениями.

4. «В зависимости от условий» — то есть речь не идёт просто о списке команд, которые выполняются подряд одна за одной. Некоторые из команд выполняются при наступлении каких-то условий (нажатие на клавишу, приход пакета с данными по сети, фаза Луны). 

Это всё «программирование». 

Если программа исполняется непосредственно на компьютере пользователя (в том числе браузере), это называют «клиентским» программированием (front-end). Если где-то на сервере, обрабатывает запросы множества программ-клиентов, отвечает на них и что-то себе делает — «серверным» (back-end). Всем известная в индустрии несправедливость — бэкендеры в среднем зарабатывают больше чем фронтендеры, хотя их работа не сложнее. :) 

Так, теперь про обещанные в куррикулуме «пять миров». Это не классификация программирования, а скорее рабочих мест и целых секторов индустрии.

Джоэл наш Спольски пишет (и он прав), что можно работать программистом в одном из пяти миров:

— «продуктовое» программирование, на выходе которого некий законченный продукт, которым пользуется (хотя бы в идеале) дофига народу извне. Фейсбук, туду-лист для телефона, ядро Linux — аудитории разные, принцип один;

— «внутреннее» программирование, где программы пишутся для использования внутри компании (обычно крупной — мелкие обходятся готовым софтом, написанным «продуктовыми» компаниями). Требований там меньше, а бардака больше, поэтому раньше это было стандартным началом карьеры. Сейчас сложные программы на заказ нужны всё меньше и меньше;

— «одноразовое» программирование, где конечный продукт это вообще не программа, а результат её работы, каждый раз разный (программа пишется под результат, а потом выбрасывается). Требований к качеству кода и коллаборации с другими участниками тут почти нет. Во времена статьи Спольского это был не очень большой сектор, он приводил в пример автоматизацию сисадминами (то что сейчас называется «девопс») и академиков, но сейчас это крупнейший сектор — датасайенс, моделирование, диплёрнинг и т.п. Сейчас обычно карьера начинается отсюда (и не только начинается — я сейчас работаю именно в этом мире и очень доволен).

Это три крупных мира, есть ещё два на отшибе:

— Embedded (программирование микроэлектроники и прочий низкий уровень). Населён инженерами, которые наивно посчитали, что в остальном программировании слишком большой бардак (но через полгода работы поняли, как ошибались). А также китайцами. С эмбедщиками я сталкивался мало и много про них рассказать не могу;

— Game development, разработка компьютерных игр. Это ловушка, не ходите сюда никогда!

Средняя сложность встречаемых задач в порядке возрастания (это моё личное мнение, и ооочень условное): одноразовое – внутреннее – эмбед – продуктовое – геймдев (но последний бывает и не очень сложный, там любой бардак возможен). Точнее, не «задач», а напряжённости работы, что ли. Какой из этих миров вам показался наиболее привлекательным?

### Вопросы и ответы

      *— 3 пункт. написание и выполнение программы происходит в разное время, правильно? или ты пишешь=>выполняешь=>видишь результат*
      *— Правильно. Но в процессе работы это время очень близко друг к другу (есть такая возможность; когда компьютеры были тёплыми и ламповыми, это не очень получалось). То есть да — написал-запустил-посмотрел-выругался-поправил-запустил-посмотрел…*

      *— Низкое и системное - они оба обращаются сразу к железу? А высокое в некой операционной системе?*
      *— В программировании высокого уровня посредников между вами и железом может быть много, например, библиотеки javascript/браузер/его компоненты и библиотеки/операционка/железо (бывает и хуже)*

      *— (Это не вопрос, просто печальное замечание) Эта прекрасная картина в четырех пунктах рисует абстрактное программирование в идеальной среде. И никак не оговаривает, что на практике среда наносит дофига ограничений и модификаций. Насколько ржавый сустав у робота, которого мы учим двигать руками. Какой объем памяти у устройства, на котором крутится наше приложение, и каким образом его операционка влияет на то, сколько памяти мы будем использовать и что будет происходить при нехватке или конкуренции за нее с другими программами. В общем, всякие штуки, которые относятся не к задаче, которую должна выполнить программа, а к оптимизации процесса выполнения и всяким граблям, навязанным средой выполнения. Тут же большой барьер. Когда правильные в теории алгоритмы ни фига не превращаются в реально работающую программу в реальной среде. (А теперь вопросы) В какой степени по-твоему надо понимать про низкоуровневое, чтобы что-то реальное сделать, насколько надо это на концептуальном уровне этих четырех пунктов оговаривать, и будем ли мы что-то про это изучать когда будем трогать руками реальное?*
      *— В мире программирования много фрустрации, тут ничего не поделаешь. :) Чтобы «что-то делать», то есть по-настоящему приносить пользу и зарабатывать деньги, про низкий уровень можно вообще ничего не знать, совершенно необязательно. Но если знать, то можно брать проекты поинтереснее, а программы писать пооптимальнее.*

      *— Почему не ходить в геймдев?*
      *— Самые сложные задачи, самая низкая оплата, самое плохое отношение к сотрудникам — это геймдев. Ну некоторым нравится доширак, я и сам его люблю, но вот недели по 100 часов за копейки…*

      *— (про внутреннее программирование) Вот тут я всегда плаваю, как что называть. Бывает, когда есть контора, которая внутри себя для своих нужд что-то пишет.  Бывает, когда есть контора, которая пишет что-то для другой конторы для нужд той, второй конторы. Обе эти ситуации подпадают под вариант 3, а то, кто именно выполняет работу - вторично? (английский термин - in-house, верно?)*
      *— Для определения мира это вторично, принципы работы одни. Может быть in-house, может быть аутсорс, неважно*
      *— А! Инхаус - это как раз второе измерение, да? То есть есть измерение "продуктовая--внутренняя", а есть "инхаус --аутсорс"?*
      *— Ага*

## S01E02. Командная строка

Так, в предыдущем выпуске мы установили, что программировать значит писать команды, чтобы они выполнялись средой выполнения (в зависимости от каких-то условий). Хотя программы записываются в текстовых файлах и только потом компилируются и/или запускаются на выполнение, программисту бывает очень полезно отдавать команды (неважно чему) непосредственно, и видеть результат сразу же. Это означает, что большую часть времени он не вылезает из места, где работать с командами удобнее всего — командной строки.

Командные строки бывают где угодно. Например, в браузере если выбрать в меню Developer Tools, можно найти Javascript Console, или просто Console. Это командная строка к среде выполнения браузера, где можно писать команды, короткие программы и отлаживать код, который браузер выполняет (этим мы займёмся в другой день).

В любой операционной системе, как правило, тоже есть командная строка. Программа, которая позволяет с ней работать, называется **shell** («оболочка», но так не говорят), а окно с текстовым интерфейсом, в котором мы работаем, называется **терминал** (шелл запускается в терминале, как правило автоматически при запуске последнего).

Большая часть действий, требуемых программисту (создание/удаление файлов и директорий, запуск программ, компиляция, работа с системами контроля версий, обращение к сетевым API), как правило, осуществляется из командной строки. Пытаться обходиться без неё можно, и какое-то время будет даже получаться — современные графические среды разработки включают в себя почти всё, и работу с файлами, и отладчики, и даже контроль версий. Но это ловушка: рано или поздно нужно будет выполнить какую-то операцию, которую автор среды разработки не предусмотрел; командная строка предоставляет универсальный язык, поэтому если что-то можно сделать в принципе, это можно сделать через командную строку / шелл.

Люди понапридумывали множество операционных систем, в которых мы работаем. Теоретически, в каждой из них должны быть свои терминалы, команды и особенности работы. На практике сейчас на персональных компьютерах остались либо UNIX-совместимые ОС (macOS, Linux), в которых всё очень похоже друг на друга, либо Windows. Жить и программировать в последней можно, но всё немножко другое; по ряду причин на серверах, как правило, в любом случае стоят UNIX-системы (в 99% случаев Linux), поэтому программисты тоже себе устраивают UNIX-среду и соответствующий шелл. Что сделаем и мы.

(Многие (но не все) языки программирования также предоставляют командную строку, для того чтобы проверять результаты коротких выражений, вести отладку и взаимодействовать с кодом непосредственно. Такая оболочка называется **REPL — Read-Evaluate-Print Loop**. Консоль в браузере — один из примеров REPL (для языка Javascript), но они бывают много где.)

Командная строка операционной системы оптимизирована в первую очередь для работы с сервисами операционной системы. Это в первую очередь: создание-удаление-чтение-запись файлов и директорий, управление процессами (запущенными программами), поиск файлов, фильтрация их содержимого, а также очень много чего ещё, что нам сейчас не понадобится.

### Практика 1.1: терминал, основные команды bash

Итак, запускаем терминал. В Linux и macOS он обычно так и называется Terminal (в macOS его можно найти в Applications/Utilities). В Windows, как я уже говорил, нужно установить msys2 с сайта www.msys2.org и запустить их терминал (тоже msys2), который даёт UNIX-совместимую среду в Windows (в терминале программисты проводят много времени, поэтому настраивают его под себя, особенно в macOS, где он по умолчанию крошечный. Я делаю шрифт побольше, светло-серый на чёрном, размер окна 100x30 символов; вы можете сделать как вам удобно).

  *Note: запускать нужно не просто MSYS2, а MSYS2 MingW 64-bit*

Итак, терминал сразу запускает шелл и показывает какую-то командную строку. Шеллов бывает много разных, но мы все видим один конкретный, который называется bash, он вездесущ. Он не лишён недостатков и исторических проблем, но научиться с ним работать всё равно необходимо (по причине везесущести), а потом привыкаешь.

В компьютере есть обширная файловая система, а шелл работает с файлами. В каждый момент времени мы «находимся» в какой-то директории (а именно — «домашней» директории), которую можно узнать командой pwd, а сменить — командой cd. Вот можно набрать pwd и посмотреть что получится.

  *—pwd - это print working (?) directory, а cd - это change directory)*
  *— Примерно так. Мнемоники UNIX-команд оставляют желать, запоминаются обычно механически от частого употребления*

В Mac и Linux мы находимся в «настояшей» домашней директории, а в Windows — в искусственной, которая создана специально для этой UNIX-среды. Так не годится, поэтому там нужно перейти в настоящую. Для этого нужно набрать подряд две команды:

    cd /c/Users 
    ls

и посмотреть, как называется ваша домашняя директория.

В списке будут All Users, Default, Default User, desktop.ini, Public и ещё одна директория, которая у каждого называется по-разному: она-то вам и нужна. После того как вы её нашли, нужно сделать

    cd <эта директория>

и мы на месте.

В общем, все наконец находятся в домашней директории 🙂 Сделаем ls и посмотрим, что там есть. Как правило, благодаря гигантским усилиям по стандартизации операционных систем, там будет директория Desktop, которая отражает то, что находится на рабочем столе. Нужно перейти туда (cd Desktop). (Если у вас её нет, скопируйте то что есть сюда (в чат), посмотрим как оно называется.)

Команда cd принимает абсолютные (полные) и относительные пути в файловой системе. Абсолютные пути в UNIX-среде начинаются с /, и отсчитываются с корневой директории. В Windows есть отдельные диски, а в UNIX-среде файловая система одна, а разные диски привязаны (это называется mounted) в какие-то директории под корнем (каждый раз разные). Но с / начинается системный диск.

В macOS домашняя директория находится по пути /Users/имя_пользователя, в Linux /home/имя_пользователя, в Windows c:\Users\имя_пользователя, и в UNIX-среде это транслируется как /c/Users/имя_пользователя.

Когда из домашней директории мы пишем cd Desktop, это относительный путь. Bash знает, в какой директории мы находимся, и достраивает его до абсолютного.

Мы знаем команды cd и ls, правда, пока без параметров.
Третья команда, которую мы запомним — mkdir, "make directory"

Если мы находимся в директории Desktop, пишем:

    mkdir LearnToCode

и удостоверяемся, что на вашем рабочем столе волшебным образом появилась соответствующая директория.

Если директория пустая, её можно удалить командой `<rmdir>` (а если не пустая, на то есть другая команда, но о ней я расскажу чуть позже, она ошибок не прощает) 🙂

А потом можно опять `<mkdir>`. А чтобы не писать всё каждый раз заново, есть волшебная кнопка — стрелка вверх. Она перебирает историю команд, и когда мы находим такую же, можно просто нажать enter (а если похожую, можно отредактировать).

У команды mkdir есть параметр -p, который позволяет создавать несколько вложенных директорий сразу.

Если у команды есть опции, то как правило команда выглядит так:

    команда <опции> объект_применения

Например, `<mkdir -p LearnToCode/1/2/3/4/5>` создаст много вложенных директорий сразу. Можете попробовать.

А `<ls -l>` (это тоже маленькая l) выведет более подробную информацию о файлах.

Список опций к каждой команде можно посмотреть командой man, например man ls (ОСТОРОЖНО, ИХ РЕАЛЬНО ОЧЕНЬ МНОГО — никто не помнит всё наизусть). Да и man сейчас мало кто использует, когда есть гугл, который всё знает не хуже. Выходить из man кнопкой `<q>`.

One more thing: в баше есть комбинации клавиш Ctrl-A (попасть в начало строки), Ctrl-E (в конец строки) и Ctrl-W (удалить последнее слово), они очень пригождаются при редактировании, чтобы не нажимать стрелки миллион раз. 🙂 Тоже можно попробовать.

На сегодня пока всё. Домашнее задание — убедиться, что всё что было сегодня работает, посоздавать пустые директории и поудалять их.

## S01E03. Командная строка - продолжение

Исходное положение — терминалы открыты, вы находитесь в директории Desktop (как туда попасть, я объяснял в прошлый раз), создали директорию LearnToCode и перешли туда. :)

Рассмотрим ещё несколько UNIX-команд. Например, есть такая команда echo, которая просто выводит свои аргументы на экран. Чтобы в этом убедиться, можно написать echo LearnToCode.

"Аргумент" — штука интересная. Bash любит иметь собственное мнение, что считать аргументами команды, поэтому то, что подаётся на вход echo, принято для избавления от путаницы брать в кавычки. Например: echo "Hello, world!" Хотя в принципе будет работать и просто echo Hello, world!, но другие команды таких вольностей могут и не простить.

Казалось бы, зачем нужно повторять вывод текста на экран? (Поэтому echo так и называется). Однако, от этой команды есть польза, и для того чтобы её проявить, нужно знать, что такое "перенаправления потока" в UNIX.

Почти каждая unix-команда — это небольшая (а бывает что и большая) программа, как правило, написанная на C. UNIX-подобные операционные системы предоставляют каждой запущенной программе полезные сервисы (сигналы, потоки, переменные среды и т.п.)

Нам сейчас важно, что у каждой программы есть три стандартных "потока ввода-вывода" — STDIN, STDOUT и STDERR. По умолчанию, то что программа пишет в STDOUT, выводится на экран, STDERR тоже на экран (используется для сообщений об ошибках), а STDIN — по умолчанию запрашивает текстовый ввод от пользователя в терминале. Но все эти умолчания можно переопределить!

### Практика 1.2

Например, с помощью символа > можно перенаправить стандартный вывод программы с экрана, к примеру, в файл (если указать имя файла сразу после >). 

Пример:

    echo ‘Hello, world!’ > hello.txt

Наберите и посмотрите что получится (посмотреть можно командой ls или прямо на десктопе).

Правильно использовать одинарные кавычки  везде. Сейчас объясню почему. Находящееся в двойных кавычках bash должен воспринимать как один аргумент, но он интерпретирует служебные символы. Восклицательный знак — служебный символ, служит для ссылки на предыдущую команду. Его интерпретация может быть в разных ОС включена или выключена по умолчанию, что мы и наблюдаем.

У меня была отключена. :) Но так может повезти не всем, поэтому для просто вывода текста нужно использовать одинарные кавычки, тогда строка выводится "как есть".
Как правильно тут сказали, можно повторить команду с другим текстом в кавычках, и содержимое перезапишется.

  *—Ага, а если написать команду еще раз, он не добавляет новый текст в файл, а заменяет старый новым. Интересно, а добавить можно, или это бесполезный навык?*
  *—Чтобы этого не произошло, вместо > можно использовать >>
  тогда содержимое добавляется в файл новой строкой*

А чтобы не делать новую строку, у echo есть опция -n, попробуйте с ней

    echo -n 'Some new text' >> hello.txt

Посмотрите, в чём разница с -n и без него.

А чтобы каждый раз не открывать файл, его можно вывести на экран командой cat

    cat hello.txt

  *—У меня с -n сначала создаёт новую строку, а если второй раз сделать так же, то добавляет к последней строке.*
  *—^ да, я забыл что под виндовс «новая строка» может отличаться. используйте cat.*

А теперь фокус: cat hello.txt > hello2.txt. 

hello2.txt — это точная копия hello.txt (cat прочитала hello.txt, вывела поток, и он перенаправился в hello2.txt). 

Так можно копировать файлы, но лучше (быстрее) пользоваться для этого командой cp: cp file1 file2 скопирует file1 в file2.

Так, едем дальше. Тайна, почему cat так называется.

Попробуйте: cat hello.txt hello2.txt > hello3.txt

Cat может воспринимать несколько аргументов (имён файлов) и выводить их подряд. Вывод можно перенаправить в ещё какой-то файл. Теперь в файле hello3.txt будет подряд содержимое hello1.txt и hello2.txt. Операция последовательного объединения называется конкатенация, и cat это мнемоника от conCATenate. Но чаще всего cat используется просто для вывода содержимого индивидуальных файлов.

Помимо операции перенаправления >, в UNIX есть очень часто используемая операция | (читается как pipe). Найдите этот символ у себя на клавиатуре, потому что он очень часто используется. Pipe означает "передать вывод одной программы на вход другой программе" (и cat, и echo — не встроенные команды bash, а отдельные программы). Как вы, наверное, догадались, вывод другой программы можно передать на вход третьей программе, и т.д. Иногда это бывает полезно.

Например, есть такая команда grep, которая предназначена для поиска какого-то текста в файлах. У неё ОЧЕНЬ МНОГО опций, на которых мы не будем сейчас останавливаться — по умолчанию она ищет построчно в том, что подаётся её на вход, то что вы написали в аргументе, и выводит на выход строки, в которых это нашлось. Таким образом, grep выполняет роль построчного (по умолчанию) фильтра.

Пример использования:

    cat hello3.txt |grep Hello

(при этом если написать cat hello3.txt |grep hello, то ничего не выведется — команда чувствительна к регистру. Но это можно убрать опцией -i, то есть cat hello3.txt |grep -i hello снова будет работать, и искать hello, Hello, или там hELLo тоже)

Команда mv перемещает (например, в другую директорию) файл, или переименовывает его.

mv имя_файла имя_директории перемещает файл в директорию, а mv имя_файла имя_файла_2 переименовывает файл.

Чтобы не писать каждый раз длинные абсолютные пути, есть соглашения: текущая директория обозначается точкой, а родительская - двумя точками (. и ..).

Например, mv hello.txt .. переместит файл hello.txt в родительскую директорию (то есть на десктоп, если вы находитесь в Desktop/LearnToCode).

Команда rm удаляет файлы. Ей нужно пользоваться с большой осторожностью, потому что она не перемещает файлы в корзину, а удаляет их навсегда без спроса.

Попробуйте rm hello2.txt

По умолчанию rm не удаляет директории.

Но есть команда rm -r, которая удаляет директории со всем содержимым, включая поддиректории.

Каждый раз когда вы её применяете, нужно два раза перепроверять команду на ошибки (я не шучу).

Каждый программист хоть раз за свою карьеру стёр с помощью rm -r ЧТО-ТО НЕ ТО :)

Вернитесь на Desktop (cd .., если вы находитесь в LearnToCode) и удалите LearnToCode со всем содержимым:

    rm -r LearnToCode

## S01E04. Интерпретаторы и компиляторы, менеджер пакетов. Устанавливаем node.js,clang и Vscode

### Интерпретаторы и компиляторы

У языков программирования бывают интерпретаторы и компиляторы. Сейчас разница между этими понятиями размылась, но представление о граничных вариантах спектра можно иметь.

Если мы пишем программу на языке программирования, и какая-то другая программа загружает её текст (исходный код) и начинает выполнять команды одна за одной, следовать условиям, циклам и т.п. — такая штука называется "интерпретатор".

Если же вместо этого программа загружает ваш исходный код, тщательно рассматривает имеющиеся в нём команды, убирает лишние (оптимизирует), и потом переводит эти команды либо непосредственно в машинный код, либо в команды другого языка программирования (как правило, попроще) — такая конструкция называется "компилятором". В том случае если компилятор преобразовал программу сразу в машинный код, записал его в исполняемый файл и установил связи со всеми используемыми библиотеками функций — мы получаем на выходе (помимо прочего) исполняемый файл для имеющейся у нас ОС, который сразу же можно запустить из шелла, а то и двойным нажатием.

Про "установление связи с библиотеками функций" следует сказать чуть подробнее. Как правило, ни одна программа не пишется с самого начала — она очень активно использует уже готовые функции, написанные когда-то другими программистами. В зависимости от того, где эти готовые функции находятся, они могут называться:
- в ядре операционной системы — системными вызовами или системным API (system calls, system API);
- в комплекте поставки самого языка программирования — функциями стандартной библиотеки (standard library);
в библиотеках, написанных другими программистами, которые нужно устанавливать отдельно — библиотеками зависимостей (libraries, dependencies);
- в других программах — локальным API (application programming interface);
- где-то неведомо где, в на чужих серверах, в интернете — удалённым API (remote API).

Задача программиста, как правило — самому написать поменьше, а чужого использовать побольше (бывают исключения, особенно когда чужое написано плохо, делает не то, или его слишком много — а так обычно и бывает).

Интерпретатор языка программирования обычно умеет вызывать библиотечные функции самостоятельно (тем или иным способом), и предоставляет вам к ним доступ средствами кода. Компилятор же сначала заменяет вызовы библиотечных функций на заглушки ("так, вот здесь нужно будет вызвать системную функцию open, которая открывает файл"), а потом на следующем этапе другая программа (линкер) записывает туда управляющую последовательность машинного кода, которая загружает в память библиотеку или код системного вызова (или находит уже загруженную), передаёт ей управление с нужными аргументами, и потом не забывает вернуться назад, к коду основной программы.

Разумеется, одни библиотеки могут использовать другие библиотеки, те — третьи, они в свою очередь опять первые, всё это зависит друг от друга самыми причудливыми способами и снабжает программиста бесконечным развлечением — находить, где именно оно сломалось на этот раз.

У каждого языка программирования, как правило, есть своя стандартная библиотека — набор комплектных функций, которые что-то делают. Она бывает как довольно компактной (как, например, у C), так и просто огромной (как у Java). Также у каждого языка программирования есть своя "экосистема зависимостей" — средства организации библиотек, написанных другими программистами, чтобы их было удобно устанавливать, использовать, и применять. Иногда по несколько штук того и другого (например у Javascript есть "стандартная библиотека" в браузере и "стандартная библиотека" самого популярного серверного интерпретатора Node.js, а про количество менеджеров зависимостей даже вспоминать не хочется).

Да, подавляющее большинство "зависимостей", то есть дополнительных библиотек, о которых идёт речь, имеют открытый исходный код и ими можно пользоваться совершенно свободно (есть некоторые юридические тонкости с разными открытыми лицензиями, но они вас пока не касаются). Можно долго говорить о том, почему так получилось, но вообще это очень удобно.

### Менеджеры пакетов

Помимо менеджеров зависимостей языков программирования, с которыми мы будем работать чуть позже, у операционных систем есть свои менеджеры пакетов — программы, которые из командной строки могут устанавливать, обновлять и удалять другие программы (в том числе языки программирования и библиотеки, устанавливаемые на системном уровне и доступным для многих языков одновременно).

### Практика 1.3: установка менеджера пакетов и обновление базы

В Ubuntu встроенный менеджер пакетов называется apt. В msys2 — pacman (он взят из Arch Linux). На macOS обычно устанавливают homebrew. Те кто на маке должны сейчас его установить отсюда: https://brew.sh. Homebrew и pacman в msys2 умеют работать с правами обычного пользователя; для apt нужны права администратора, то есть запускать его нужно через sudo (то есть sudo apt ...)

Обновите базу доступных пакетов. На msys2 делать ничего не надо, мы уже обновили в прошлый раз.

На маке нужно написать:

    brew update 

на убунту/mint:

    sudo apt update

(он скорее всего спросит ваш пароль)

### Практика 1.4: установка Clang, node.js и vscode

Мы поставим компилятор C (clang) и интерпретатор javascript (node.js)

на линуксе:
    
    sudo apt install clang

на маке:

    brew install --with-toolchain llvm (brew install node)

на виндовс:

    pacman -S clang

На маке clang входит в пакет программ разработчика, которые не входят в homebrew, а устанавливаются так:

    xcode-select --install

на msys2 пакет с node.js называется сложнее:
устанавливается так: 

    pacman -S mingw-w64-x86_64-nodejs

После того как всё установится, удостоверьтесь что команды cc (от C Compiler) и node находятся и работают.

Наконец, всем нужно поставить текстовый редактор Visual Studio Code, он в менеджеры пакетов обычно не входит, и его нужно поставить отдельно с сайта :) очень популярный программистский текстовый редактор (но вообще их огромное множество).

Если из командной строки, то

    sudo apt install путь_к_файлу
    или
    sudo dpkg -i путь к файлу.

Итак, после сегодня у вас должны быть: clang, node.js и vscode

Помимо моего альцгеймера, сегодняшнее занятие хорошо иллюстрирует, что на разных ОС бывают самые разные проблемы с настройкой рабочей среды (и соответственно как сложно писать программы, которые бы работали везде) :)

  *В этот замечательный момент индеец Зоркий Глаз обнаружил, что у msys2 есть несколько терминалов с разными настройками. И запускать нужно не просто MSYS2, а MSYS2 MingW 64-bit (находится в start menu, если начать набирать mingw).*
  *Там пути к исполняемым файлам установлены нормально, поэтому и node, и cc должны заработать. Простите, виндовс у меня стоит невесть где, и я редко им пользовался. :)*
  
## S01E05. Воргейм

Сегодня будет весёлое практическое задание. С кучей вопросов преподавателю, потому что задание сложное. Зато поможет вам быстро освоить остальные UNIX-команды, потому что так я объясняю слишком медленно. Но для этого сначала нужно убедиться, что у вас установлен SSH (secure shell) — программа, с помощью которой можно устанавливать соединение с другими компьютерами и заходить в шелл там. У тех у кого мак и линукс, ssh установлен по умолчанию (вроде). А людям с виндовс опять не повезло. В общем, наберите ssh — если он говорит not found, значит сейчас будем его ставить.

### Практика 1.5: установка ssh (только для windows)

Те у кого виндовс и msys2, пишут такую команду:

    pacman -Syu

это менеджер пакетов, о котором пойдёт речь в следующем занятии. Он обновит базу доступных пакетов и попросит закрыть окно терминала. Закройте и потом запустите ещё раз. А потом наберите

    pacman -S openssh

и ssh установится.

### Практика 1.6: wargame (Квест-тренировка команд bash и умения гуглить)

Сегодня мы играем в воргейм! Он же CTF. Обычно воргеймы сложные и предназначены для самообразования хакеров, мнээ, то есть специалистов во компьютерной безопасности. Но я нашёл один довольно простой, который служит для закрепления понимания UNIX:

https://overthewire.org/wargames/bandit/

(Ну то есть это для безопасников простой, а для вас сложный, поэтому готовьтесь и бойтесь).

Воргейм состоит из нескольких уровней. На каждый из них нужно залогиниться с помощью ssh, выяснить там пароль к следующему уровню и потом залогиниться с этим паролем уже туда. Выход из шелла — Ctrl-D (если это было удалённое соединение по ssh, оно прерывается). Начинаем с уровня 0: http://overthewire.org/wargames/bandit/bandit0.html

  *—а на следующий уровень нужно логиниться, запуская  ssh на этом сервере, или разлогиниваться и снова у себя?*
  *—разлогиниваться и снова залогиниваться*

Порт указывается параметром -p. То есть если имя пользователя user, адрес соединения address и порт 2020, команда выглядит так:

    ssh -p 2020 user@address

И пишете пароль когда спросят. Поехали! :)
Я думаю, 10 уровней сможете осилить :)

Вы находитесь в шелле на каком-то сервере. Посмотрите, что там есть, какие файлы. Выведите на экран. Первый уровень сложнее, чем несколько последующих. Если вы не сможете нагуглить, что с ним делать, обращайтесь. Дальше будет легче 🙂
Там в инструкции написано don't give up, это важно.

Для того чтобы пройти контрольную, достаточно попасть на 1 уровень.
3 уровень — вам пятёрка.
Всё что выше — пятёрка с плюсом.
10 уровень — вы мегамолодец и можете гордиться неделю.
Если вы смогли пройти дальше, вы не начинающий точно, ну окей, давайте :)

NB - на каждый следующий уровень логин меняется. Сначала bandit0, потом bandit1, bandit2 и т.д.

## S01E06. Протоколы, API

Раньше, когда компьютеры были большими, тёплыми и ламповыми (зачёркнуто), программы писались для локального использования, продавались индивидуальным клиентам, работали на одном компьютере, и общались с внешним миром посредством файлов, записываемых на дискету. А, да, и продавались в магазине в затянутых в целлофан коробках, прямо как книжки или электроника — можете себе представить? Большинство обучающих материалов по программированию отражают положение дел тех времён — типа, вы можете писать сами себе программы, отлаживать их на своём компьютере, а когда придёт время — выпустить релиз и распространять его.

Сейчас, конечно, всё по-другому.

### Протоколы (или как построен интернет)

Сейчас кругом интернет, и без него чихнуть некуда: одни программы находятся на серверах и показывают странички сайтов и принимают данные, другие выполняются прямо в браузере, и даже немногочисленные "нативные" приложения, то есть те, которые в браузере не работают, всё равно общаются с другими программами по интернету. Вот, например, телеграм, в который мы сейчас пишем. Без интернет-коммуникаций никуда, и сейчас я попытаюсь очень абстрактно и коротко объяснить, как это происходит.

Интернет построен на _протоколах_, то есть шаблонах, которым должны соответствовать пересылаемые между компьютерами данные. Для функционирования интернета требуется множество протоколов, завёрнутых друг в друга и использующих друг друга. Например, для передачи стандартизированных пакетов данных между компьютерами используется протокол IP, для передачи потоков данных без потерь и дупликатов служит протокол TCP (который использует IP в качестве более нижнего уровня) — и, наконец, для передачи содержимого сайтов, а также, что важнее, для общения программ между собой в интернете используется протокол HTTP. Он текстовый, то есть его содержимое представляет текст, который могут прочитать люди (а TCP и IP — бинарные протоколы, они работают с "сырой" информацией с байтами и смещениями, что тоже не представляет ничего сложного — в конце концов, текст это тоже байты — но требует инструментов для анализа и разбора).

Программист использует протоколы согласно требуемым ему уровням абстракции. Использовать TCP/IP напрямую нужно лишь в редких случаях, когда вы пишете какой-то очень оптимизированный собственный транспортный протокол и точно знаете, что вам нужно с точностью до байта. Во всех остальных случаях для передачи данных с моделью "отправил запрос — получил ответ" лучше использовать протокол HTTP, который работает везде и используется всегда.

Но и текстовое содержание протокола HTTP утомительно собирать вручную (к тому же, легко ошибиться). Любой современный язык программирования содержит средства сборки запросов HTTP со всеми требуемыми заголовками и параметрами, либо в стандартной библиотеке, либо в какой-нибудь из часто употребимых. (каждый раз, когда вы открываете сайт — сервер по протоколу HTTP передаёт браузеру содержимое сайта в формате HTML (тоже текстовом), а браузер знает, как полученную кашицу, то есть текстовый HTML-ответ, превратить в хорошо свёрстанный текст на экране с картинками. Подробности этого процесса мы изучим позже).
Для нас сейчас важно, что по протоколу HTTP можно передавать не только HTML, но и в принципе всё что угодно. Благодаря этому "что угодно" можно отправлять запросы разным сервисам в интернете, которые предназначены не для людей, а для программистов — или, как мы говорим, "предоставляют API".

### API

API, как мы помним — это Application Programming Interface.

Сейчас, в 2019 году, существует великое множество интернет-API, которые позволяют взаимодействовать с миром, не покидая компьютера и командной строки. Через API можно заказать Uber, покупать еду, смотреть погоду, искать работу, и, возможно, даже запускать баллистические ракеты (если знать пароль и быть подсоединённым к нужной сети). Сегодня мы будем использовать API, который умеет звонить по телефону (Twilio). Когда мы говорим о том, что по HTTP можно передавать "что угодно", это правда. Но обычно в качестве чего угодно для работы с API используются определённые _форматы данных_ (способы записи произвольной информации). Два наиболее распространённых — это XML и JSON.

Так может выглядеть XML:

    <tag parameter1="value1" parameter2="value2">
      content
    </tag>

(теги могут быть вложены друг в друга, и обычно бывают)

А так JSON:

    {"parameter1": "value1", "parameter2": "value2", "parameter3": ["array", "of", "values"]}

Я сейчас не буду расписывать подробное устройство того и другого — показываю просто чтобы вы запомнили, кто зовётся ежом, а кто черепахой слывёт, и могли опознать то и другое на практике.

### Практика 1.7: автоматический звонок на телефон через Twilio API

Теперь перейдём к практической части. Для общения с интернет-API, использующими HTTP, есть команда curl, но мы её сегодня использовать не будем, а будем писать сразу на Javascript — в стандартную библиотеку интерпретатора node.js входят средства для работы с HTTP. Но мы стандартную библиотеку использовать не будем, а возьмём библиотеку попроще, которая позволит обойтись минимальными знаниями Javascript.

Сегодня я просил вас создать поддиректорию для сегодняшнего проекта (ltc01). Перейдите в неё. :)

Нам понадобятся такие Javascript-библиотеки, которые мы установим средствами npm:

1. Now.js — это целая платформа, но от неё нам нужна функциональность, которая бесплатно позволяет размещать в интернете файлы
2. sync-request — та самая простая библиотека для работы с HTTP.

Итак, когда вы зашли в директорию проекта, наберите

    npm init

этим мы создадим новый проект на Javascript на node.js. Npm задаст ряд вопросов :)

Почти все из них можно пропустить (нажать enter), кроме:

    description — тут наберите, например, LearnToCode Project 01
    author: ваши имя-фамилию на английском :)

(жду пока всё получится, у кого не получается — задавайте вопросы)

  *—А test command?*
  *—не нужно*
  *—package name?*
  *—такой же, ltc01, предложен по умолчанию*

Пока вы это делаете, я расскажу, как работает API звонков Twilio. Он несколько нестандартный, в смысле состоит из двух этапов, когда можно было бы обойтись одним. Ну да ладно. Мы сконструируем http-запрос на сервер, на котором работает API. В нём указывается аккаунт на Twilio (для того чтобы каждому не создавать по полчаса, будем использовать мой -- хотя потом можно создать и собственный), номера телефонов, и интернет-адрес, где можно скачать XML-файл с содержимым звонка. Этот файл мы сейчас создадим и разместим, для этого нужно установить now.js.

~~У кого mac или linux — наберите (находясь в директории проекта)
    sudo npm install -g --unsafe-perm now
(now придирается к правам доступа).
А у кого windows — должно работать без sudo:
    npm install -g now~~

Дальше мы создадим директорию static, а в ней файл demo.xml, который будет читать сервер Twilio. Пустой файл можно создать командой touch, то есть:

    touch demo.xml

После чего запустите VS Code и откройте им директорию проекта (Open Folder, кажется), то есть ltc01.

  *— учитель, я не понимаю, почему мы в одном и том же терминале набираем команды от разных мммм штуковин, которые мы установили на комп. как терминал понимает, что это команда от того, что мы поставили? как в них не перемешиваются команды?*
  *—Очень хороший вопрос! В UNIX-среде bash ищет команды в директориях, записанных в переменную среды PATH. Откуда она берётся это отдельный вопрос, но посмотреть её текущее содержимое можно командой*

    echo $PATH

  *(список директорий разделён двоеточием). И вот bash ищет: есть ли в первой директории из списка команда (программа) такая-то? если нет, то может во второй? и т.д. Находит — запускает, не находит — пишет, что команда не найдена*

В редакторе с открытым проектом находим в панели слева файл demo.xml. Нажимаем на него, он открывается в панели редактора. Это XML-формат Twilio, о котором нужно читать в их документации. Там куча возможностей, но мы просто создадим файл, который описывает произнесение одного предложения на русском. Запишите в demo.xml вот что:

    <?xml version="1.0" encoding="UTF-8"?>
    <Response>
        <Say voice="woman" language="ru-RU">Привет! Теперь ты программист, живи с этим</Say>
    </Response>

Вместо этого текста (который начинается с "Привет") можно написать любой другой, не сильно длинный.

Сохраните xml-файл нажатием Ctrl-S или Cmd-S на маке. Перейдите в терминале директорию static, где этот файл находится

    cd static

~~и наберите now
(вам нужно будет ответить на вопросы и создать аккаунт, после чего файл будет загружен на серверы Now и доступен по интернету)~~

Итак, нам повезло нарваться на свежий баг now: https://github.com/zeit/now-cli/issues/1894. Добро пожаловать в волшебный мир программирования :)

Но ничего страшного, now нам был нужен, только чтобы малой кровью разместить файлик demo.xml где-то в интернете, чтобы он был доступен по какому-то URL. 

Сейчас я сделаю это сам; магия "напишите любой текст" будет потеряна, но основную часть работы мы выполним и звонок будет. (Потом, когда у нас будет гитхаб, мы сможем выкладывать файлы в интернет другим способом). 

В общем, если бы now работал как положено (а у большинства людей он похоже не работает), после этого этапа он выдал бы адрес в интернете (URL), где размещён файл demo.xml, который мы сейчас создали. Например, такой: https://static-l63gh37tq.now.sh/demo.xml  У кого не получилось — будем использовать его.

Ладно. Возвращаемся в директорию проекта (ltc01), устанавливаем там библиотеку sync-request:

    npm install --save sync-request

а я пока объясню тот минимум языка Javascript, который будет нам необходим, чтобы понять дальнейшее.

Программа на Javascript (и на других языках тоже) состоит из последовательности выражений (statements). Вот типы выражений, которые нам сегодня нужны:

    let some_variable = "value" 

— присваивание значения переменной. Когда в дальнейшем в программе мы будем писать some_variable, интерпретатор вместо этого подставит её значение (строку "value" в данном случае, но это может быть и число, и блок кода).

    function(param1, param2, param3, ...)

— вызов функции с аргументами, которых может быть произвольное количество, в том числе ни одного. Вызванная функция что-то делает, и по результатам может вернуть какое-то значение (а может и не вернуть).

Если мы хотим возвращённое значение присвоить опять переменной, это делается понятно как:

    let some_variable = function(...)

Запускаем node! (в директории проекта, то есть ltc01).

Проверяем полученные знания: вызываем функцию console.log (точка означает, что это "метод" log в объекте console, но это сейчас неважно). Пишем

    console.log("Hello")

Эта функция печатает на экран свой аргумент.

Можно это сделать с переменной:

    let x = "Some text"
    console.log(x)

  *—и еще серое undefined печатает, кроме Hello.*
  *—Да, потому что REPL пишет последнее возвращённое значение, а console.log ничего не возвращает.*

Тут нужно пояснение по поводу особенностей работы REPL. Любое выражение, которое мы туда пишем, он выполняет (осуществляются действия, связанные с ним), а потом печатает результат (для всех выражений, кроме присваиваний). Когда программа (в файле, например) выполняется интерпретатором без REPL, результаты каждого выражения на экран не выводятся. Чтобы что-то явно вывести на экран, нужно вызывать функцию console.log.  Но console.log можно вызвать и в repl, тогда напечатается во-первых то, что подано в качестве аргумента для этой функции, а также то, что она возвращает (console.log ничего не возвращает, поэтому мы видим undefined)

  *—слово let в присваивании опционально?*
  *—да, но по ряду причин, о которых пойдёт речь в следующем модуле, лучше его не опускать.*

Дальше. В Javascript есть операция конкатенации (стыковки) строк, которая выражается оператором + между строками.

Напишите, например 'fox' + 'trot' (результатом должна быть одна строка, 'foxtrot')

Последнее замечание — блоки и структуры данных.

В Javascript несколько выражений можно заключать между фигурными скобками { } (одно выражение на одной строке, или их можно разделять точкой с запятой). Результатом выполнения такой конструкции является результат выполнения последнего выражения. Например: {'a'; 'b'}. Фигурные скобки также используются в похожем синтаксисе вложенных структур данных, например:

    let obj = {'some': 'data', 'num': 5}

То, что в фигурных скобках — это структура данных (Javascript-объект), к внутренностям ("полям") которого можно обращаться отдельно.попробуйте написать просто obj.

  *—А почему let ? В браузерном JS ведь var используется?*
  *—можно var, но let лучше, потому что var создаёт переменные в глобальной видимости, а let — нет. Let появился сравнительно недавно.*

Let даёт присвоить объектам значение только один раз. Возможно, вы пытаетесь сделать это второй раз. :)

Это спасает от опечаток и ошибок последовательности в программе, но если нужно переопределить значение переменной во второй раз в том же контексте, пишите без let. То есть

    obj = {'some': 'data', 'num': 5}

Уф. Теперь создаём файл index.js в директории проекта (ltc01), открываем его и пишем туда вот что (уже должно быть более или менее понятно, что происходит)

    let request = require('sync-request')
(так выглядит использование библиотеки, которую мы установили раньше — в переменной request теперь объект с кучей функций, которые можно вызывать и делать запросы по протоколу http)

    let account = '<censored>'
    let apiKey = '<censored>'
(это логин и пароль от моего API-аккаунта Twilio — господа профессионалы, держите себя в руках и не делайте с ним ничего сверх этой практики)

let voiceUrl = 'https://static-6ln1t4egq.now.sh/demo.xml'
это адрес XML-файла, из которого Twilio будет брать содержимое звонка. Если now у вас заработал, можете записать вместо этого адреса тот, который он вам выдал, а если нет, оставьте этот

let fromPhone = '+14703800003'
это номер телефона, с которого будет звонок (оставьте его таким)

let toPhone = '...'
а тут вместо многоточия напишите ваш номер телефона в международном формате без пробелов (если в России, то +7что-то-там)

let pass = new Buffer(account + ':' + apiKey).toString('base64')
эта сложная строчка упаковывает логин-пароль в формат, понимаемый http (сейчас @Arkenoi тоже будет жаловаться, но слова не давали)

let apiUrl = 'https://' + account + ':' + apiKey +
'@api.twilio.com/2010-04-01/Accounts/' + account + '/Calls.json'
Из кусков строчек и переменных мы собираем API URL, к которому будем отправлять запрос.

let data = 'Url=' + voiceUrl + '&To=' + toPhone + '&From=' + fromPhone + '&Method=GET'
Из других кусков строк и переменных мы собираем содержимое запроса — данные, которые нужны API для завершения запроса

console.log('API URL: ' + apiUrl)
console.log('Data: ' + data)
эти две строчки выведут на экран URI и содержимое запроса, которые мы собрали

let response = request('POST', apiUrl, {
headers: {
'content-type': 'application/x-www-form-urlencoded',
'Authentication': 'Basic ' + pass
},
body: data
})
Эта огромная команда — собственно, вызов http-запроса (функция request с параметрами, которые нужны именно для этого запроса — в виде вложенной структуры. Параметр body — это переменная data, которую мы собрали).

console.log(response.getBody('utf8'))
Последняя строчка выводит результат выполнения http-запроса (нужно указать кодировку utf-8, чтобы он вывелся правильно — про кодировки я расскажу позднее).

Удостоверяемся что ваш номер телефона записан верно, записываем файл (он должен быть в директории ltc01) и из терминала запускаем:

node index.js

У кого всё получилось, тот молодец, получит звонок :)

P.S финальный код в файле index.js в итоге выглядит так:
let request = require('sync-request')
let account = 'AC4ef21469e8bde0760b3904705221f526'
let apiKey = '8fe0ceaecb4638f9451acc113181d163'
let voiceUrl = 'https://static-6ln1t4egq.now.sh/demo.xml'
let fromPhone = '+14703800003'
let toPhone = '+79118423897'
let pass = new Buffer(account + ':' + apiKey).toString('base64')
let apiUrl = 'https://' + account + ':' + apiKey + '@api.twilio.com/2010-04-01/Accounts/' + account + '/Calls.json'
let data = 'Url=' + voiceUrl + '&To=' + toPhone + '&From=' + fromPhone + '&Method=GET'
console.log('API URL: ' + apiUrl)
console.log('Data: ' + data)
let response = request('POST', apiUrl, {
   headers: {
     'content-type': 'application/x-www-form-urlencoded',
     'Authentication': 'Basic ' + pass
   },
   body: data
})
console.log(response.getBody('utf8'))

##Основные команды bash

- pwd - узнать, в какой мы директории
- cd - выбрать директорию
- ls - посмотреть, что есть в данной директории (также полезно ls -Al, которая отображает скрытые файлы)
- mkdir - создать директорию и rmdir - удалить (пустую директорию)
- echo - вывести на экран аргументы команды
- cat - вывести на экран содержимое файла (а еще скопировать файлы один в другое и проч.)
- | (pipe) -передать вывод одной программы на вход другой программе
- grep - Утилита grep позволяет не только фильтровать вывод других команд, но и искать по содержимому файловой системы.
- mv - Перемещает файл
- rm - удалить файлы

<To Be Continued>

Основные команды Git

<To Be Continued>
